<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>N-LABS95 — DNA Generator 9.5 (Base Sepolia)</title>
<style>
  :root{ --win-bg:#008080; --win-panel:#c0c0c0; --win-blue:#000080; }
  html,body{margin:0;padding:0}
  body{
    background:var(--win-bg);
    font-family:'MS Sans Serif', Tahoma, Arial, sans-serif;
    display:flex;justify-content:center;min-height:100vh
  }
  .desktop{width:min(900px,98vw);margin:14px}
  .window{background:var(--win-panel);border:2px solid #fff;box-shadow:2px 2px 0 #000}
  .title-bar{background:var(--win-blue);color:#fff;font-weight:bold;padding:4px 8px;
             display:flex;align-items:center;justify-content:space-between}
  .title-right{display:flex;gap:6px}
  .title-btn{padding:2px 8px;background:#c0c0c0;color:#000;border:1px solid #fff;
             text-align:center;line-height:16px;font-size:12px;cursor:pointer}
  .content{background:#fff;border:2px inset #c0c0c0;padding:10px}
  .tabs{display:flex;gap:6px;margin-bottom:8px;flex-wrap:wrap}
  .tab{padding:4px 10px;background:#c0c0c0;border:2px outset #fff;cursor:pointer;font-size:14px;user-select:none}
  .tab.active{border:2px inset #fff;background:#ddd}
  .pane{display:none; min-height:620px;}
  .pane.active{display:block}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:6px}
  select,input[type=text]{background:#fff;border:2px inset #fff;padding:4px;font-size:14px}
  select{min-width:210px}
  input[type=text]{width:120px}
  button{padding:4px 10px;background:#c0c0c0;border:2px outset #fff;cursor:pointer;font-size:14px}
  button:active{border:2px inset #fff}
  button:disabled{color:#777;cursor:not-allowed;border:2px inset #fff}
  input[type=range]{min-width:140px}
  .hint{font-size:12px;color:#000080;margin:6px 0}
  .badge{font-size:12px;background:#ececec;border:1px solid #999;padding:2px 6px}
  canvas{
    display:block;border:2px solid #000;background:#eee;
    margin:8px auto;              /* center */
    max-width:100%; height:auto;  /* responsive */
  }
  .status{font-size:12px;margin-top:4px;word-break:break-all}
  .coming{padding:18px;background:#efefef;border:2px inset #c0c0c0; min-height:620px;}
  .footer{font-size:11px;color:#222;margin-top:6px;opacity:.9}

  /* share bar */
  .share-bar{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .share-btn{padding:6px 10px;background:#c0c0c0;border:2px outset #fff;cursor:pointer;font-size:13px}
  .share-btn:active{border:2px inset #fff}

  /* simple card grid */
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px;margin-top:10px}
  .card{background:#f7f7f7;border:2px inset #c0c0c0;padding:10px;cursor:pointer}
  .card:hover{filter:brightness(0.98)}
  .card h4{margin:0 0 6px 0;font-size:14px}
  .card p{margin:0;font-size:12px;color:#333}
  .note{font-size:12px;color:#333;margin-top:10px}

  /* ABOUT retro screen */
  .lab-screen{background:#000;border:2px inset #c0c0c0;padding:10px;color:#0ff;margin-bottom:12px}
  .lab-head{font-weight:bold;color:#0ff;margin-bottom:6px;text-shadow:0 0 4px #0ff}
  .dash{stroke-dasharray:8 12;animation:flow 3.5s linear infinite}
  .helix1{stroke:#ff00ff;animation-delay:0s}
  .helix2{stroke:#00ffff;animation-delay:-1s}
  .helix3{stroke:#ffff00;animation-delay:-2s}
  .helix4{stroke:#ff6600;animation-delay:-3s}
  .rungs line{stroke:#00ffcc;stroke-width:2;opacity:.8;animation:blink 2s ease-in-out infinite alternate}
  .crt{color:#0f0;text-shadow:0 0 6px #0f0;margin-top:6px;font-size:12px}
  @keyframes flow{to{stroke-dashoffset:-64}}
  @keyframes blink{from{opacity:.4} to{opacity:1}}

  @media (max-width:560px){
    .row > *{flex:1 1 auto}
    select{min-width:unset}
  }
</style>
</head>
<body>
<div class="desktop">
  <div class="window">
    <div class="title-bar">
      <div>N-LABS95 — DNA Suite</div>
      <div class="title-right">
        <button id="connectBtn" class="title-btn" title="Connect Wallet">Connect</button>
        <div class="title-btn" title="Maximize">□</div>
        <div class="title-btn" title="Close">X</div>
      </div>
    </div>
    <div class="content">
      <!-- Tabs (reordered) -->
      <div class="tabs" id="tabs">
        <div class="tab active" data-pane="about">About</div>
        <div class="tab" data-pane="artists">Artists</div>
        <div class="tab" data-pane="gallery">Gallery</div>
        <div class="tab" data-pane="mint">Mint</div>
      </div>

      <!-- ABOUT (active by default) -->
      <div id="pane-about" class="pane active">
        <div class="coming">
          <div class="lab-screen">
            <div class="lab-head">[N-LABS95] :: CRT DNA MONITOR</div>
            <svg width="100%" height="260" viewBox="0 0 600 260" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <rect x="0" y="0" width="600" height="260" fill="#000"/>
              <path class="dash helix1" d="M0,130 C50,80 100,180 150,130 S250,80 300,130 S350,180 400,130 S450,80 500,130 S550,180 600,130" fill="none" stroke-width="3"/>
              <path class="dash helix2" d="M0,130 C50,180 100,80 150,130 S250,180 300,130 S350,80 400,130 S450,180 500,130 S550,80 600,130" fill="none" stroke-width="3"/>
              <path class="dash helix3" d="M0,130 C50,60 100,200 150,130 S250,60 300,130 S350,200 400,130 S450,60 500,130 S550,200 600,130" fill="none" stroke-width="2.5"/>
              <path class="dash helix4" d="M0,130 C50,200 100,60 150,130 S250,200 300,130 S350,60 400,130 S450,200 500,130 S550,60 600,130" fill="none" stroke-width="2.5"/>
              <g class="rungs">
                <line x1="25" y1="100" x2="25" y2="160"/>
                <line x1="75" y1="160" x2="75" y2="100"/>
                <line x1="125" y1="100" x2="125" y2="160"/>
                <line x1="175" y1="160" x2="175" y2="100"/>
                <line x1="225" y1="100" x2="225" y2="160"/>
                <line x1="275" y1="160" x2="275" y2="100"/>
                <line x1="325" y1="100" x2="325" y2="160"/>
                <line x1="375" y1="160" x2="375" y2="100"/>
                <line x1="425" y1="100" x2="425" y2="160"/>
                <line x1="475" y1="160" x2="475" y2="100"/>
                <line x1="525" y1="100" x2="525" y2="160"/>
                <line x1="575" y1="160" x2="575" y2="100"/>
              </g>
            </svg>
            <div class="crt">> status: MULTI-HELIX ONLINE — chromatic flux stabilized — neon spectrum engaged.</div>
          </div>

          <b>About — N-LABS95</b><br/><br/>
          <i>N-LABS95 is a DNA laboratory for digital art. We believe every artwork — whether generative, illustrative, or photographic — hides a genetic blueprint waiting to be revealed.</i>
          <br/><br/>
          <i>Our vision: N-LABS95 will become a central hub for artists and collectors — a place where creativity, technology and community meet; from minting experimental strands to launching full collections. By decoding artistic DNA, we bring artworks to life in new, unexpected forms.</i>
        </div>
      </div>

      <!-- ARTISTS -->
      <div id="pane-artists" class="pane">
        <div class="coming">
          <b>Artists</b><br/><br/>
          The Artists space will be the heart of N-LABS95.
          A platform where creators introduce themselves, present their vision, and release collections.
          Not only generative experiments, but also photography and traditional art translated into digital DNA.
          <div class="grid" id="artistsGrid">
            <div class="card" data-type="artist" data-slug="lab-collective">
              <h4>N-LABS Collective</h4>
              <p>Foundational DNA experiments.</p>
            </div>
            <div class="card" data-type="artist" data-slug="alice-photo">
              <h4>Alice (Photography)</h4>
              <p>Chromatic field studies in grain and light.</p>
            </div>
            <div class="card" data-type="artist" data-slug="orbit-studio">
              <h4>ORBIT Studio</h4>
              <p>Helix geometry & motion design.</p>
            </div>
          </div>
          <div class="note">Soon: artist pages with profiles, links, and collection launch tools.</div>
        </div>
      </div>

      <!-- GALLERY -->
      <div id="pane-gallery" class="pane">
        <div class="coming">
          <b>Gallery</b><br/><br/>
          The Gallery will evolve into a shared archive of DNA artworks and collections.
          Here, collectors can showcase their mints, and artists — from digital painters to photographers —
          can launch new strands of their work.
          <div class="grid" id="galleryGrid">
            <div class="card" data-type="gallery" data-slug="dna-series-01">
              <h4>DNA Strand — Series 01</h4>
              <p>Chromatic study from a classic collection.</p>
            </div>
            <div class="card" data-type="gallery" data-slug="photo-dna-01">
              <h4>Photo DNA — Light & Grain</h4>
              <p>Photographic texture rendered as DNA.</p>
            </div>
            <div class="card" data-type="gallery" data-slug="abstract-helix">
              <h4>Abstract Helix</h4>
              <p>Fragments, density, and drift.</p>
            </div>
          </div>
          <div class="note">Soon: open submissions and artist-curated drops.</div>
        </div>
      </div>

      <!-- MINT -->
      <div id="pane-mint" class="pane">
        <div class="row">
          <select id="collectionSelect" title="Choose a collection">
            <option value="boredapeyachtclub|0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d">Bored Ape Yacht Club (BAYC)</option>
            <option value="mutant-ape-yacht-club|0x60e4d786628fea6478f785a6d7e704777c86a7c6">Mutant Ape Yacht Club (MAYC)</option>
            <option value="azuki|0xed5af388653567af2f388e6224dc7c4b3241c544">Azuki</option>
            <option value="doodles-official|0x8a90cab2b38dba80c64b7734e58ee1db38b8992e">Doodles</option>
            <option value="chimpers|0x80336ad7a747236ef41f47ed2c7641828a480baa">Chimpers</option>
            <option value="proof-moonbirds|0x23581767a106ae21c074b2276d25e5c3e136a68b">Moonbirds</option>
            <option value="pudgypenguins|0xbd3531da5cf5857e7cfaa92426877b022e612cf8">Pudgy Penguins</option>
            <option value="cryptopunks|0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb">CryptoPunks</option>
            <option value="mocaverse|0x59325733eb952a92e069c87f0a6168b29e80627f">Mocaverse</option>
            <option value="mfers|0x79fcdef22feed20eddacbb2587640e45491b757f">MFers</option>
          </select>
          <input id="tokenIdInput" type="text" placeholder="Token ID" />
          <button id="loadBtn">Load NFT</button>
          <span id="nftBadge" class="badge">No NFT loaded</span>
        </div>

        <div class="row">
          <label>Nucleotide Density <input id="sequenceRange" type="range" min="1" max="10" value="5"/></label>
          <label>Helix Drift <input id="driftRange" type="range" min="1" max="10" value="6"/></label>
        </div>

        <div class="row">
          <button id="generateBtn" disabled>Generate</button>
          <button id="mintBtn" disabled>Mint on Base Sepolia</button>
        </div>

        <div class="hint">
          Every NFT carries a hidden DNA. This app decodes its chromatic sequence and grows new strands from it.
          <b>Nucleotide Density</b> controls fragment density & scale, while <b>Helix Drift</b> curves the flow paths across the canvas.
        </div>

        <canvas id="canvas" width="600" height="600"></canvas>
        <div id="statusText" class="status">Choose a collection and enter a Token ID, then click “Load NFT”.</div>

        <!-- Share bar (appears after mint) -->
        <div id="shareBar" class="share-bar" style="display:none;">
          <button id="shareWarpcast" class="share-btn">Share on Farcaster</button>
          <button id="shareBaseApp" class="share-btn">Share in Base app</button>
          <button id="shareCopy" class="share-btn">Copy link</button>
        </div>

        <div class="footer">Chain: Base Sepolia (84532) • Contract: <span id="contractAddrFoot"></span></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.min.js";

/* ===================== CONFIG ===================== */
const RAW_CONTRACT_ADDRESS = "0xeA13E39C6fF7a70fC1Bd4F213D08BA395d336BCB";
const CONTRACT_ADDRESS = RAW_CONTRACT_ADDRESS.replace(/\s+/g, "");
const ADDRESS_RE = /^0x[0-9a-fA-F]{40}$/;
if (!ADDRESS_RE.test(CONTRACT_ADDRESS)) {
  alert("Config error: CONTRACT_ADDRESS is not a valid 0x address.");
  throw new Error("Invalid CONTRACT_ADDRESS");
}
const BASE_SEPOLIA_CHAIN_ID = 84532;
const EXPLORER = "https://sepolia.basescan.org";
const MINT_PRICE_ETH = "0.0";
const UPLOAD_MODE = "server";
const WEB3_STORAGE_TOKEN = "";

document.getElementById('contractAddrFoot').textContent = CONTRACT_ADDRESS;

/* =============== UI REFS & STATE =============== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const collectionSelect = document.getElementById('collectionSelect');
const tokenIdInput = document.getElementById('tokenIdInput');
const loadBtn = document.getElementById('loadBtn');
const generateBtn = document.getElementById('generateBtn');
const mintBtn = document.getElementById('mintBtn');
const sequenceRange = document.getElementById('sequenceRange');
const driftRange = document.getElementById('driftRange');
const statusText = document.getElementById('statusText');
const nftBadge = document.getElementById('nftBadge');
const connectBtn = document.getElementById('connectBtn');

const shareBar = document.getElementById('shareBar');
const btnWarpcast = document.getElementById('shareWarpcast');
const btnBaseShare = document.getElementById('shareBaseApp');
const btnCopy = document.getElementById('shareCopy');

let provider, signer, userAddress;
let nftImage = null;
let nftImageData = null;
let bgPastelHex = '#f8f8f8';
let currentSeed = null;
let lastLoadedKey = null;
let lastTxHash = null;
let lastImageGateway = null;
let lastExplorerTx = null;

/* ================= Tabs ================== */
function activateTab(tabEl){
  document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
  document.querySelectorAll('.pane').forEach(x=>x.classList.remove('active'));
  tabEl.classList.add('active');
  const pane = document.getElementById('pane-'+tabEl.dataset.pane);
  if (pane) pane.classList.add('active');
}
document.getElementById('tabs').addEventListener('click', (e)=>{
  const t = e.target.closest('.tab');
  if (!t) return;
  activateTab(t);
});

/* ======= Simple placeholders ======= */
function showComingSoon(kind, slug){
  alert(`${kind === 'artist' ? 'Artist profile' : 'Gallery item'} “${slug}” coming soon.`);
}
document.addEventListener('click', (e)=>{
  const card = e.target.closest('#artistsGrid .card, #galleryGrid .card');
  if (!card) return;
  const type = card.dataset.type;
  const slug = card.dataset.slug;
  showComingSoon(type, slug);
});

/* ============== Chain Helpers ============== */
async function ensureWallet(){
  if(!window.ethereum){ alert('Please install MetaMask / Coinbase Wallet'); throw new Error('no wallet'); }
  provider = new ethers.BrowserProvider(window.ethereum);
  signer = await provider.getSigner();
  userAddress = await signer.getAddress().catch(()=>null);
  return signer;
}
async function ensureBaseSepolia(){
  const net = await provider.getNetwork();
  if(Number(net.chainId) !== BASE_SEPOLIA_CHAIN_ID){
    await window.ethereum.request({
      method:"wallet_addEthereumChain",
      params:[{
        chainId: "0x14A34",
        chainName: "Base Sepolia",
        nativeCurrency:{ name:"ETH", symbol:"ETH", decimals:18 },
        rpcUrls:["https://sepolia.base.org"],
        blockExplorerUrls:[EXPLORER + "/"]
      }]
    });
  }
}
connectBtn.addEventListener('click', async ()=>{
  try{
    await ensureWallet();
    await ensureBaseSepolia();
    const addr = await signer.getAddress();
    connectBtn.textContent = 'Connected';
    statusText.textContent = `Wallet: ${addr}`;
    if (lastLoadedKey) { tryDuplicateCheck(); }
  }catch(e){ console.warn(e); }
});

/* ============== NFT Fetch ============== */
function ipfsToHttp(u){ return u?.startsWith('ipfs://') ? ('https://ipfs.io/ipfs/'+u.slice(7)) : u }
async function fetchNFTImage(slug, contract, tokenId){
  try{
    const r = await fetch(`https://api.reservoir.tools/tokens/v7?tokens=${contract}:${tokenId}`);
    if(r.ok){
      const j = await r.json();
      const url = j?.tokens?.[0]?.token?.image || j?.tokens?.[0]?.token?.imageLarge;
      if(url) return ipfsToHttp(url);
    }
  }catch(e){}
  try{
    const r = await fetch(`https://api.opensea.io/api/v2/collection/${slug}/nfts/${tokenId}`);
    if(r.ok){
      const j = await r.json();
      const url = j?.nft?.image_url || j?.nft?.image_original_url;
      if(url) return ipfsToHttp(url);
    }
  }catch(e){}
  return null;
}

/* ======= Color / DNA Helpers ======= */
function clamp(v,min,max){ return Math.min(max,Math.max(min,v)); }
function rgbToHsl(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2;
  if(max===min){ h=s=0; } else { const d=max-min; s=l>0.5? d/(2-max-min): d/(max+min);
    switch(max){ case r: h=(g-b)/d+(g<b?6:0); break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break; } h/=6; }
  return [h,s,l]; }
function hslToRgb(h,s,l){ let r,g,b; if(s===0){ r=g=b=l; } else {
  const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; };
  const q=l<0.5? l*(1+s): l+s-l*s, p=2*l-q; r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3); }
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)]; }
function rgbToHex(r,g,b){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }
function dominantColorFromImage(img){
  const t=document.createElement('canvas'); t.width=64; t.height=64;
  const c=t.getContext('2d',{willReadFrequently:true});
  c.drawImage(img,0,0,64,64);
  const d=c.getImageData(0,0,64,64).data;
  const map=new Map(); const step=8;
  for(let i=0;i<d.length;i+=4*step){
    const a=d[i+3]; if(a<200) continue;
    const r=(d[i]/16|0)*16, g=(d[i+1]/16|0)*16, b=(d[i+2]/16|0)*16;
    const k=`${r},${g},${b}`; map.set(k,(map.get(k)||0)+1);
  }
  let best=null, cnt=-1;
  for(const [k,v] of map.entries()){ if(v>cnt){ best=k; cnt=v; } }
  if(!best) return {r:248,g:248,b:248};
  const [r,g,b]=best.split(',').map(n=>parseInt(n));
  return {r,g,b};
}
function pastelizeFromRGB(r,g,b){
  let [h,s,l]=rgbToHsl(r,g,b);
  l = clamp(l + 0.10, 0, 1); s = clamp(s - 0.06, 0, 1);
  const [R,G,B]=hslToRgb(h,s,l);
  return rgbToHex(R,G,B);
}

/* ============== DNA Render (unchanged) ============== */
function mulberry32(seed){ return function(){ let t=seed+=0x6D2B79F5;
  t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; }; }
function getCharacterPriorityColors(imageData, count=15){
  const colors={}, step=12, d=imageData.data;
  for(let i=0;i<d.length;i+=4*step){
    const r=d[i], g=d[i+1], b=d[i+2];
    const brightness=(r+g+b)/3;
    const saturation=Math.max(r,g,b)-Math.min(r,g,b);
    const key=`${r},${g},${b}`;
    const weight=(saturation*0.6)+(Math.abs(128-brightness)*0.2)+10;
    colors[key]=(colors[key]||0)+weight;
  }
  let sorted=Object.entries(colors).sort((a,b)=>b[1]-a[1]);
  const bg=sorted[0]?.[0]; sorted=sorted.filter(c=>c[0]!==bg);
  const top=sorted.slice(0,count*3); const out=[]; let bgShare=0;
  for(const [rgb,w] of top){
    if(w<5) continue;
    if(bgShare<2 && out.length<2){ out.push(`rgb(${rgb})`); bgShare++; }
    else if(out.length<count){ out.push(`rgb(${rgb})`); }
  }
  return out.slice(0,count);
}
const brushPatterns=[];
function createBrushPatterns(context){
  brushPatterns.length=0;
  for(let i=0;i<3;i++){
    const b=document.createElement('canvas'); b.width=40; b.height=40;
    const bc=b.getContext('2d'); bc.fillStyle=`rgba(0,0,0,${0.03+Math.random()*0.05})`;
    for(let j=0;j<50;j++){ bc.fillRect(Math.random()*40,Math.random()*40,1+Math.random()*2,1+Math.random()*2); }
    brushPatterns.push(context.createPattern(b,'repeat'));
  }
}
function generateFlowPaths(count,size,rng){
  const paths=[]; for(let i=0;i<count;i++){
    paths.push([{x:rng()*size,y:rng()*size},{x:rng()*size,y:rng()*size},{x:rng()*size,y:rng()*size}]);
  } return paths;
}
function bezierPoint(p0,p1,p2,t){
  return { x:(1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x,
           y:(1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y };
}
function drawHex(ctx, r){ ctx.beginPath(); for(let i=0;i<6;i++){ const a=(Math.PI/3)*i; ctx.lineTo(r*Math.cos(a), r*Math.sin(a)); } ctx.closePath(); ctx.fill(); }
function drawShape(x,y,size,c1,c2,context,rng){
  context.save(); context.translate(x,y); context.rotate(rng()*Math.PI);
  const g=context.createLinearGradient(-size/2,-size/2,size/2,size/2);
  g.addColorStop(0,c1); g.addColorStop(1,c2); context.fillStyle=g;
  context.shadowColor='rgba(0,0,0,0.15)'; context.shadowBlur=10*(size/100);
  context.shadowOffsetX=5*(size/150); context.shadowOffsetY=5*(size/150);
  const r=rng();
  if(r<0.2){ context.beginPath(); context.arc(0,0,size/2,0,Math.PI*2); context.fill(); }
  else if(r<0.4){ context.fillRect(-size/2,-size/2,size,size); }
  else if(r<0.6){ context.beginPath(); context.moveTo(-size/2,size/2); context.lineTo(size/2,size/2); context.lineTo(0,-size/2); context.closePath(); context.fill(); }
  else if(r<0.8){ drawHex(context,size/2); }
  else{ context.fillRect(-size/2,-size/4,size,size/2); }
  context.globalAlpha=0.8; context.fillStyle=brushPatterns[(rng()*brushPatterns.length)|0];
  context.fillRect(-size/2,-size/2,size,size); context.globalAlpha=1; context.restore();
}
function drawFlowLines(paths,ctx){ ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1;
  for(const p of paths){ ctx.beginPath(); ctx.moveTo(p[0].x,p[0].y); ctx.quadraticCurveTo(p[1].x,p[1].y,p[2].x,p[2].y); ctx.stroke(); } }
function chaosFragment(colors,sequence,drift,context,size,scale,rng){
  const big=sequence*2, mid=sequence*8, small=sequence*15;
  const paths=generateFlowPaths(drift,size,rng);
  const draw=(n,a,b)=>{ for(let i=0;i<n;i++){ const path=paths[(rng()*paths.length)|0];
    const t=rng(); const p=bezierPoint(path[0],path[1],path[2],t);
    const s=(a + rng()*(b-a))*scale; const c1=colors[(rng()*colors.length)|0]; const c2=colors[(rng()*colors.length)|0];
    drawShape(p.x,p.y,s,c1,c2,context,rng); } };
  draw(big,80,140); draw(mid,40,70); draw(small,15,30); drawFlowLines(paths,context);
}
function addNoise(context,size){
  const d=context.getImageData(0,0,size,size);
  for(let i=0;i<d.data.length;i+=4){ const n=(Math.random()-0.5)*25; d.data[i]+=n; d.data[i+1]+=n; d.data[i+2]+=n; }
  context.putImageData(d,0,0);
}

/* ============== ABI (duplicate check only) ============== */
const ABI = [
  {
    "inputs": [
      { "internalType": "string",  "name": "tokenURI_",        "type": "string"  },
      { "internalType": "address", "name": "sourceCollection", "type": "address" },
      { "internalType": "uint256", "name": "sourceTokenId",    "type": "uint256" }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "collection", "type": "address" },
      { "internalType": "uint256", "name": "tokenId",    "type": "uint256" }
    ],
    "name": "hasBeenUsed",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  }
];

/* ============== Duplicate Check ============== */
async function tryDuplicateCheck(){
  try{
    if(!signer || !lastLoadedKey) return;
    const parts = lastLoadedKey.split('|');
    const sourceCollection = (parts[1] || '').trim();
    const sourceTokenId = BigInt(tokenIdInput.value.trim() || '0');
    if (!ADDRESS_RE.test(sourceCollection)) return;
    const c = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
    const already = await c.hasBeenUsed(sourceCollection, sourceTokenId);
    if (already){
      statusText.textContent = '⚠️ Already minted from this source. (blocked on-chain)';
      mintBtn.disabled = true;
    }
  }catch(e){ console.warn('Duplicate check failed:', e); }
}

/* ============== Load NFT ============== */
loadBtn.addEventListener('click', async ()=>{
  const [slug,sourceCollectionAddrRaw] = (collectionSelect.value || '').split('|');
  const sourceCollectionAddr = (sourceCollectionAddrRaw || '').trim();
  const tokenId = (tokenIdInput.value || '').trim();
  if(!tokenId){ statusText.textContent='Please enter a Token ID.'; return; }
  if(!ADDRESS_RE.test(sourceCollectionAddr)){ statusText.textContent='Invalid collection address.'; return; }

  statusText.textContent='Loading NFT…';
  nftBadge.textContent='Loading…'; generateBtn.disabled=true; mintBtn.disabled=true;

  const url = await fetchNFTImage(slug, sourceCollectionAddr, tokenId);
  if(!url){ statusText.textContent='NFT not found (or CORS blocked).'; nftBadge.textContent='No NFT loaded'; return; }

  const img = new Image(); img.crossOrigin='anonymous';
  img.onload = async ()=>{
    const dom = dominantColorFromImage(img);
    bgPastelHex = pastelizeFromRGB(dom.r,dom.g,dom.b);

    ctx.fillStyle = bgPastelHex; ctx.fillRect(0,0,canvas.width,canvas.height);
    const cw=canvas.width,ch=canvas.height, ir=img.width/img.height;
    let dw=cw, dh=cw/ir; if(dh>ch){ dh=ch; dw=dh*ir; }
    const dx=(cw-dw)/2, dy=(ch-dh)/2;
    ctx.drawImage(img,dx,dy,dw,dh);

    nftImageData = ctx.getImageData(0,0,canvas.width,canvas.height);
    statusText.textContent = `Loaded • ${slug} #${tokenId}`;
    nftBadge.textContent = `${slug} #${tokenId}`;
    generateBtn.disabled=false; mintBtn.disabled=true;
    lastLoadedKey = `${slug}|${sourceCollectionAddr}|${tokenId}`;

    if (signer) { tryDuplicateCheck(); }
    activateTab(document.querySelector('.tab[data-pane="mint"]')); // stay on Mint after load
  };
  img.onerror = ()=>{ statusText.textContent='Failed to load image.'; nftBadge.textContent='No NFT loaded'; };
  img.src = url;
});

/* ============== Generate ============== */
generateBtn.addEventListener('click', ()=>{
  if(!nftImageData){ alert('Load an NFT first.'); return; }
  ctx.fillStyle = bgPastelHex; ctx.fillRect(0,0,canvas.width,canvas.height);
  createBrushPatterns(ctx);
  const colors = getCharacterPriorityColors(nftImageData, 15);
  const sequence = +sequenceRange.value, drift = +driftRange.value;
  currentSeed = Math.floor(Math.random()*1e9);
  const rng = mulberry32(currentSeed);
  chaosFragment(colors,sequence,drift,ctx,600,1,rng);
  addNoise(ctx,600);
  statusText.textContent='Generated — ready to mint.';
  mintBtn.disabled=false;
});

/* ============== Upload helper ============== */
async function uploadViaServer(files){
  const fd = new FormData();
  files.forEach(f => fd.append('file', f.blob, f.name));
  const r = await fetch('/api/upload',{ method:'POST', body:fd });

  let text = null, payload = null;
  try { text = await r.text(); } catch {}
  try { payload = text ? JSON.parse(text) : null; } catch {}

  if(!r.ok){
    const msg = (payload && (payload.error || payload.message)) || text || `Upload API failed (HTTP ${r.status})`;
    throw new Error(msg);
  }
  return payload || {};
}
async function uploadViaWeb3Storage(files){
  if(!WEB3_STORAGE_TOKEN) throw new Error('WEB3_STORAGE_TOKEN missing');
  const endpoint='https://api.web3.storage/upload';
  const imgRes = await fetch(endpoint,{ method:'POST', headers:{ Authorization:`Bearer ${WEB3_STORAGE_TOKEN}` }, body: files[0].blob });
  if(imgRes.status===413) throw new Error('413: image too large');
  if(!imgRes.ok) throw new Error('image upload failed');
  const imageCid = (await imgRes.json()).cid;
  const imageUrl = `ipfs://${imageCid}`;
  const meta = new Blob([files[1].text],{type:'application/json'});
  const metaRes = await fetch(endpoint,{ method:'POST', headers:{ Authorization:`Bearer ${WEB3_STORAGE_TOKEN}` }, body: meta });
  if(!metaRes.ok) throw new Error('metadata upload failed');
  const metadataCid = (await metaRes.json()).cid;
  const metadataUrl = `ipfs://${metadataCid}`;
  return { imageCid, imageUrl, metadataCid, metadataUrl };
}

/* ============== Mint & Share ============== */
const ABI_MINTER = [
  {
    "inputs": [
      { "internalType": "string",  "name": "tokenURI_",        "type": "string"  },
      { "internalType": "address", "name": "sourceCollection", "type": "address" },
      { "internalType": "uint256", "name": "sourceTokenId",    "type": "uint256" }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "collection", "type": "address" },
      { "internalType": "uint256", "name": "tokenId",    "type": "uint256" }
    ],
    "name": "hasBeenUsed",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  }
];

mintBtn.addEventListener('click', async ()=>{
  try{
    if(!nftImageData){ alert('Generate first.'); return; }
    await ensureWallet(); await ensureBaseSepolia();

    // High-res Render (JPEG 1600x1600)
    const SIZE=1600, scale=SIZE/600;
    const t=document.createElement('canvas'); t.width=SIZE; t.height=SIZE;
    const tc=t.getContext('2d');
    tc.fillStyle=bgPastelHex; tc.fillRect(0,0,SIZE,SIZE);
    createBrushPatterns(tc);
    const colors = getCharacterPriorityColors(nftImageData, 15);
    const rng = mulberry32(currentSeed);
    chaosFragment(colors, +sequenceRange.value, +driftRange.value, tc, SIZE, scale, rng);
    addNoise(tc, SIZE);

    const imgBlob = await new Promise((resolve, reject) => {
      t.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
    });
    const imageFile = { name:'dna-art.jpg', blob:imgBlob };

    const [slug, sourceCollectionRaw, sourceTokenIdStr] = (lastLoadedKey || '').split('|');
    const sourceCollection = (sourceCollectionRaw || '').trim();
    if (!ADDRESS_RE.test(sourceCollection)) throw new Error('Invalid collection address');
    const sourceTokenId = BigInt(sourceTokenIdStr || '0');

    const metadata = {
      name: `N-LABS95 DNA — ${slug} #${sourceTokenId}`,
      description: "Generated DNA artwork on Base.",
      image: "ipfs://TBD",
      attributes:[
        { trait_type:"Nucleotide Density", value:+sequenceRange.value },
        { trait_type:"Helix Drift", value:+driftRange.value },
        { trait_type:"Source", value:`${slug} #${sourceTokenId}` }
      ]
    };

    statusText.textContent='Uploading to IPFS…';
    let result;
    if(UPLOAD_MODE==="server"){
      const metaText = JSON.stringify(metadata, null, 2);
      result = await uploadViaServer([
        imageFile,
        { name:'metadata.json', text:metaText, blob:new Blob([metaText],{type:'application/json'}) }
      ]);
    }else{
      const imgOnly = await uploadViaWeb3Storage([imageFile, {name:'meta-dummy.json', text:'{}', blob:new Blob()}]);
      metadata.image = imgOnly.imageUrl;
      const metaText = JSON.stringify(metadata, null, 2);
      result = await uploadViaWeb3Storage([
        imageFile,
        { name:'metadata.json', text:metaText, blob:new Blob([metaText],{type:'application/json'}) }
      ]);
    }
    const tokenURI = result.metadataUrl || result.metadataUrl_patched || "ipfs://dummy";
    if(!tokenURI) throw new Error('No metadata URL');

    const imageIpfs = result.imageUrl || null;
    lastImageGateway = imageIpfs ? ipfsToHttp(imageIpfs) : null;

    const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI_MINTER, signer);
    const already = await contract.hasBeenUsed(sourceCollection, sourceTokenId);
    if (already) { statusText.textContent = '⚠️ Already minted.'; mintBtn.disabled = true; return; }

    const value = ethers.parseEther(MINT_PRICE_ETH);
    const tx = await contract.mint(tokenURI, sourceCollection, sourceTokenId, { value });
    statusText.textContent = `Minting… Tx: ${tx.hash}`;
    const receipt = await tx.wait();

    lastTxHash = tx.hash;
    lastExplorerTx = `${EXPLORER.replace(/\/$/,'')}/tx/${tx.hash}`;
    statusText.textContent = `✅ Minted in block ${receipt.blockNumber}. View: ${lastExplorerTx}`;
    mintBtn.disabled=true;

    shareBar.style.display = 'flex';

  }catch(err){
    console.error(err);
    statusText.textContent = `❌ Mint failed: ${err?.info?.error?.message || err?.shortMessage || err?.message || String(err)}`;
  }
});

/* ============== Sharing ============== */
function buildShareText(){
  const parts = (lastLoadedKey || '').split('|');
  const slug = parts[0] || 'NFT';
  const tok = parts[2] || '';
  return `Just minted a N-LABS95 DNA from ${slug} #${tok} on Base. ⚗️🧬 #Base #NFT`;
}
btnWarpcast.addEventListener('click', ()=>{
  const text = buildShareText();
  const embeds = [];
  if (lastImageGateway) embeds.push(lastImageGateway);
  if (lastExplorerTx) embeds.push(lastExplorerTx);
  const url = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}${
    embeds.map(e => `&embeds[]=${encodeURIComponent(e)}`).join('')
  }`;
  window.open(url, '_blank');
});
btnBaseShare.addEventListener('click', async ()=>{
  const text = buildShareText() + (lastExplorerTx ? `\n${lastExplorerTx}` : '');
  try{
    if (navigator.share) {
      await navigator.share({ title: 'My DNA Mint', text, url: lastExplorerTx || undefined });
    } else {
      alert('System share not available — use “Copy link” or Farcaster.');
    }
  }catch(e){}
});
btnCopy.addEventListener('click', async ()=>{
  try{
    const text = lastExplorerTx || (lastImageGateway || window.location.href);
    await navigator.clipboard.writeText(text);
    statusText.textContent = '🔗 Link copied!';
  }catch(e){
    statusText.textContent = 'Could not copy link.';
  }
});

/* Boot */
(function boot(){
  ctx.fillStyle='#f8f8f8'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#000'; ctx.font='14px MS Sans Serif';
  ctx.fillText('Load NFT → Generate → Mint → Share.', 18, 28);
})();
</script>
</body>
</html>
