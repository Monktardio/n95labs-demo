<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>N-LABS95 — DNA Generator 9.5 (Base Sepolia)</title>
<style>
  :root{ --win-bg:#008080; --win-panel:#c0c0c0; --win-blue:#000080; }
  html,body{margin:0;padding:0}
  body{
    background:var(--win-bg);
    font-family:'MS Sans Serif', Tahoma, Arial, sans-serif;
    display:flex;justify-content:center;min-height:100vh
  }
  .desktop{width:min(900px,98vw);margin:14px}
  .window{background:var(--win-panel);border:2px solid #fff;box-shadow:2px 2px 0 #000}
  .title-bar{background:var(--win-blue);color:#fff;font-weight:bold;padding:4px 8px;
             display:flex;align-items:center;justify-content:space-between}
  .title-right{display:flex;gap:6px;align-items:center}
  .title-btn{padding:2px 8px;background:#c0c0c0;color:#000;border:1px solid #fff;
             text-align:center;line-height:16px;font-size:12px;cursor:pointer}
  .content{background:#fff;border:2px inset #c0c0c0;padding:10px}
  .tabs{display:flex;gap:6px;margin-bottom:8px;flex-wrap:wrap}
  .tab{padding:4px 10px;background:#c0c0c0;border:2px outset #fff;cursor:pointer;font-size:14px}
  .tab.active{border:2px inset #fff;background:#ddd}
  .pane{display:none; min-height:620px;}
  .pane.active{display:block}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:6px}
  select,input[type=text]{background:#fff;border:2px inset #fff;padding:4px;font-size:14px}
  select{min-width:210px}
  input[type=text]{width:120px}
  button{padding:4px 10px;background:#c0c0c0;border:2px outset #fff;cursor:pointer;font-size:14px}
  button:active{border:2px inset #fff}
  button:disabled{color:#777;cursor:not-allowed;border:2px inset #fff}
  input[type=range]{min-width:140px}
  .hint{font-size:12px;color:#000080;margin:6px 0}
  .badge{font-size:12px;background:#ececec;border:1px solid #999;padding:2px 6px}
  canvas.art{
    display:block;border:2px solid #000;background:#eee;
    margin:8px auto;
    max-width:100%; height:auto;
  }
  .status{font-size:12px;margin-top:4px;word-break:break-all}
  .coming{padding:18px;background:#efefef;border:2px inset #c0c0c0; min-height:620px;}
  .footer{font-size:11px;color:#222;margin-top:6px;opacity:.9}

  /* share bar */
  .share-bar{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .share-btn{padding:6px 10px;background:#c0c0c0;border:2px outset #fff;cursor:pointer;font-size:13px}
  .share-btn:active{border:2px inset #fff}

  /* simple card grid for gallery/artists */
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px;margin-top:10px}
  .card{background:#f7f7f7;border:2px inset #c0c0c0;padding:10px;cursor:pointer}
  .card:hover{filter:brightness(0.98)}
  .card h4{margin:0 0 6px 0;font-size:14px}
  .card p{margin:0;font-size:12px;color:#333}
  .note{font-size:12px;color:#333;margin-top:10px}

  /* ABOUT: retro screen */
  .about-wrap{background:#000;border:2px inset #222;padding:8px}
  #aboutCanvas{display:block;width:100%;height:auto;border:2px solid #0f0}
  .crt-frame{position:relative}
  .crt-frame:after{
    content:""; position:absolute; inset:0; pointer-events:none;
    background:
      linear-gradient(rgba(255,255,255,0.03), rgba(0,0,0,0.08)),
      repeating-linear-gradient(0deg, rgba(0,255,100,0.05) 0px, rgba(0,255,100,0.05) 1px, transparent 2px, transparent 3px);
    mix-blend-mode:screen;
  }
  .about-copy{color:#BFFFCF; font-size:13px; line-height:1.4; padding:10px 8px}
  .about-copy b{color:#E6FFE6}
  .about-controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .about-controls button{background:#1a1a1a;color:#9cff9c;border:1px solid #2e2e2e}

  @media (max-width:560px){
    .row > *{flex:1 1 auto}
    select{min-width:unset}
  }
</style>
</head>
<body>
<div class="desktop">
  <div class="window">
    <div class="title-bar">
      <div>N-LABS95 — DNA Suite</div>
      <div class="title-right">
        <button id="connectBtn" class="title-btn" title="Connect Wallet">Connect</button>
      </div>
    </div>
    <div class="content">
      <!-- Tabs (About, Artists, Gallery, Mint) -->
      <div class="tabs">
        <div class="tab active" data-pane="about">About</div>
        <div class="tab" data-pane="artists">Artists</div>
        <div class="tab" data-pane="gallery">Gallery</div>
        <div class="tab" data-pane="mint">Mint</div>
      </div>

      <!-- ABOUT -->
      <div id="pane-about" class="pane active">
        <div class="about-wrap">
          <div class="crt-frame">
            <canvas id="aboutCanvas" width="864" height="300"></canvas>
          </div>
          <div class="about-controls">
            <button id="aboutPauseBtn">Pause</button>
            <button id="aboutBoostBtn">Boost Color</button>
            <button id="aboutResetBtn">Reset</button>
          </div>
          <div class="about-copy">
            <b>About — N-LABS95</b><br/><br/>
            N-LABS95 is a retro-styled art laboratory — where experiments never end and the desktop hums like an old research terminal.
            Inside this lab, art is studied like science: colors, forms, and textures are tested, recombined, and launched like new formulas.<br/><br/>
            Each artwork is treated as a specimen — observed, transformed, and shared. Our vision is a central hub where creators and collectors meet:
            generative sketches, photographs, and curated collections on glowing screens — retro interfaces, fresh tech, and every release feels like pressing <i>RUN</i> on a mysterious experiment.
          </div>
        </div>
      </div>

      <!-- ARTISTS -->
      <div id="pane-artists" class="pane">
        <div class="coming">
          <b>Artists</b><br/><br/>
          The Artists space will be the heart of N-LABS95.
          A platform where creators introduce themselves, present their vision, and release collections.
          Not only generative experiments, but also photography and traditional art translated into digital formats.
          <div class="grid" id="artistsGrid">
            <div class="card" data-type="artist" data-slug="lab-collective">
              <h4>N-LABS Collective</h4>
              <p>Foundational experiments.</p>
            </div>
            <div class="card" data-type="artist" data-slug="alice-photo">
              <h4>Alice (Photography)</h4>
              <p>Chromatic field studies in grain and light.</p>
            </div>
            <div class="card" data-type="artist" data-slug="orbit-studio">
              <h4>ORBIT Studio</h4>
              <p>Helix geometry & motion design.</p>
            </div>
          </div>
          <div class="note">Soon: artist pages with profiles, links, and collection launch tools.</div>
        </div>
      </div>

      <!-- GALLERY -->
      <div id="pane-gallery" class="pane">
        <div class="coming">
          <b>Gallery</b><br/><br/>
          The Gallery will evolve into a shared archive of artworks and collections.
          Here, collectors can showcase their mints, and artists — from digital painters to photographers —
          can launch new strands of their work.
          <div class="grid" id="galleryGrid">
            <div class="card" data-type="gallery" data-slug="strand-series-01">
              <h4>Strand Series — 01</h4>
              <p>Chromatic study from a classic collection.</p>
            </div>
            <div class="card" data-type="gallery" data-slug="photo-study-01">
              <h4>Photo Study — Light & Grain</h4>
              <p>Photographic texture rendered as visuals.</p>
            </div>
            <div class="card" data-type="gallery" data-slug="abstract-helix">
              <h4>Abstract Helix</h4>
              <p>Fragments, frequency, and flow.</p>
            </div>
          </div>
          <div class="note">Soon: open submissions and artist-curated drops.</div>
        </div>
      </div>

      <!-- MINT -->
      <div id="pane-mint" class="pane">
        <div class="row">
          <select id="collectionSelect" title="Choose a collection">
            <option value="boredapeyachtclub|0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d">Bored Ape Yacht Club (BAYC)</option>
            <option value="mutant-ape-yacht-club|0x60e4d786628fea6478f785a6d7e704777c86a7c6">Mutant Ape Yacht Club (MAYC)</option>
            <option value="azuki|0xed5af388653567af2f388e6224dc7c4b3241c544">Azuki</option>
            <option value="doodles-official|0x8a90cab2b38dba80c64b7734e58ee1db38b8992e">Doodles</option>
            <option value="chimpers|0x80336ad7a747236ef41f47ed2c7641828a480baa">Chimpers</option>
            <option value="proof-moonbirds|0x23581767a106ae21c074b2276d25e5c3e136a68b">Moonbirds</option>
            <option value="pudgypenguins|0xbd3531da5cf5857e7cfaa92426877b022e612cf8">Pudgy Penguins</option>
            <option value="cryptopunks|0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb">CryptoPunks</option>
            <option value="mocaverse|0x59325733eb952a92e069c87f0a6168b29e80627f">Mocaverse</option>
            <option value="mfers|0x79fcdef22feed20eddacbb2587640e45491b757f">MFers</option>
          </select>
          <input id="tokenIdInput" type="text" placeholder="Token ID" />
          <button id="loadBtn">Load NFT</button>
          <span id="nftBadge" class="badge">No NFT loaded</span>
        </div>

        <div class="row">
          <label>DNA Frequency <input id="sequenceRange" type="range" min="1" max="10" value="5"/></label>
          <label>Gene Flow <input id="driftRange" type="range" min="1" max="10" value="6"/></label>
        </div>

        <div class="row">
          <button id="generateBtn" disabled>Generate</button>
          <button id="mintBtn" disabled>Mint on Base Sepolia</button>
        </div>

        <div class="hint">
          Every NFT carries hidden signals. This lab interface analyzes chromatic inputs and grows new visual strands.
          <b>DNA Frequency</b> controls density and repetition; <b>Gene Flow</b> bends motion across the canvas.
        </div>

        <canvas id="canvas" class="art" width="600" height="600"></canvas>
        <div id="statusText" class="status">Choose a collection and enter a Token ID, then click “Load NFT”.</div>

        <!-- Share bar (appears after mint) -->
        <div id="shareBar" class="share-bar" style="display:none;">
          <button id="shareWarpcast" class="share-btn">Share on Farcaster</button>
          <button id="shareBaseApp" class="share-btn">Share in Base app</button>
          <button id="shareCopy" class="share-btn">Copy link</button>
        </div>

        <div class="footer">Chain: Base Sepolia (84532) • Contract: <span id="contractAddrFoot"></span></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.min.js";

/* ===================== CONFIG ===================== */
const RAW_CONTRACT_ADDRESS = "0xC25562261e4E0A4235e55663f0b77B78fBE58030";
const CONTRACT_ADDRESS = RAW_CONTRACT_ADDRESS.replace(/\s+/g, "");
const ADDRESS_RE = /^0x[0-9a-fA-F]{40}$/;
if (!ADDRESS_RE.test(CONTRACT_ADDRESS)) {
  alert("Config error: CONTRACT_ADDRESS is not a valid 0x address.");
  throw new Error("Invalid CONTRACT_ADDRESS");
}
const BASE_SEPOLIA_CHAIN_ID = 84532;
const EXPLORER = "https://sepolia.basescan.org";
const UPLOAD_MODE = "server";
const WEB3_STORAGE_TOKEN = "";

document.getElementById('contractAddrFoot').textContent = CONTRACT_ADDRESS;

/* =============== UI REFS & STATE =============== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const collectionSelect = document.getElementById('collectionSelect');
const tokenIdInput = document.getElementById('tokenIdInput');
const loadBtn = document.getElementById('loadBtn');
const generateBtn = document.getElementById('generateBtn');
const mintBtn = document.getElementById('mintBtn');
const sequenceRange = document.getElementById('sequenceRange'); // DNA Frequency
const driftRange = document.getElementById('driftRange');       // Gene Flow
const statusText = document.getElementById('statusText');
const nftBadge = document.getElementById('nftBadge');
const connectBtn = document.getElementById('connectBtn');

const shareBar = document.getElementById('shareBar');
const btnWarpcast = document.getElementById('shareWarpcast');
const btnBaseShare = document.getElementById('shareBaseApp');
const btnCopy = document.getElementById('shareCopy');

let provider, signer, userAddress;
let nftImage = null;
let nftImageData = null;
let bgPastelHex = '#f8f8f8';
let currentSeed = null;
let lastLoadedKey = null;
let lastTxHash = null;
let lastImageGateway = null;
let lastExplorerTx = null;
let mintPriceWei = 0n; // <- on-chain price cache

/* ================= Tabs ================== */
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', ()=>{
    try {
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      document.querySelectorAll('.pane').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      const id = 'pane-'+t.dataset.pane;
      const pane = document.getElementById(id);
      if (pane) pane.classList.add('active');

      // wenn Mint-Tab aktiv wird und Wallet verbunden → Preis-UI aktualisieren
      if (t.dataset.pane === 'mint' && signer) refreshMintPriceUI();
    } catch(e){ console.warn('Tab switch failed:', e); }
  });
});

/* ======= Simple placeholders for future navigation ======= */
function showComingSoon(kind, slug){
  alert(`${kind === 'artist' ? 'Artist profile' : 'Gallery item'} “${slug}” coming soon.`);
}
document.querySelectorAll('#artistsGrid .card').forEach(card=>{
  card.addEventListener('click', ()=> showComingSoon('artist', card.dataset.slug));
});
document.querySelectorAll('#galleryGrid .card').forEach(card=>{
  card.addEventListener('click', ()=> showComingSoon('gallery', card.dataset.slug));
});

/* ============== Chain Helpers ============== */
async function ensureWallet(){
  if(!window.ethereum){ alert('Please install MetaMask / Coinbase Wallet'); throw new Error('no wallet'); }
  provider = new ethers.BrowserProvider(window.ethereum);
  signer = await provider.getSigner();
  userAddress = await signer.getAddress().catch(()=>null);
  return signer;
}
async function ensureBaseSepolia(){
  const net = await provider.getNetwork();
  if(Number(net.chainId) !== BASE_SEPOLIA_CHAIN_ID){
    await window.ethereum.request({
      method:"wallet_addEthereumChain",
      params:[{
        chainId: "0x14A34",
        chainName: "Base Sepolia",
        nativeCurrency:{ name:"ETH", symbol:"ETH", decimals:18 },
        rpcUrls:["https://sepolia.base.org"],
        blockExplorerUrls:[EXPLORER + "/"]
      }]
    });
  }
}
connectBtn.addEventListener('click', async ()=>{
  try{
    await ensureWallet();
    await ensureBaseSepolia();
    const addr = await signer.getAddress();
    connectBtn.textContent = 'Connected';
    statusText.textContent = `Wallet: ${addr}`;
    await refreshMintPriceUI(); // <- zeige on-chain Preis
    if (lastLoadedKey) { tryDuplicateCheck(); }
  }catch(e){ console.warn(e); }
});

/* ============== ABI SETS ============== */
// "Extended" (Anti-Dupe + price getter)
const ABI_EXTENDED = [
  {
    "inputs": [
      { "internalType": "string",  "name": "tokenURI_",        "type": "string"  },
      { "internalType": "address", "name": "sourceCollection", "type": "address" },
      { "internalType": "uint256", "name": "sourceTokenId",    "type": "uint256" }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "collection", "type": "address" },
      { "internalType": "uint256", "name": "tokenId",    "type": "uint256" }
    ],
    "name": "hasBeenUsed",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "mintPrice",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
];

// "Simple" (falls nur Preis-Getter + mint existieren)
const ABI_SIMPLE = [
  {
    "inputs": [
      { "internalType": "string",  "name": "tokenURI_",        "type": "string"  },
      { "internalType": "address", "name": "sourceCollection", "type": "address" },
      { "internalType": "uint256", "name": "sourceTokenId",    "type": "uint256" }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "mintPrice",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  }
];

/* ============== Preis lesen & UI aktualisieren ============== */
async function readMintPriceWei() {
  try {
    if (!signer) return 0n;
    try {
      const cExt = new ethers.Contract(CONTRACT_ADDRESS, ABI_EXTENDED, signer);
      return await cExt.mintPrice();
    } catch {
      const cSimple = new ethers.Contract(CONTRACT_ADDRESS, ABI_SIMPLE, signer);
      return await cSimple.mintPrice();
    }
  } catch {
    return 0n;
  }
}
async function refreshMintPriceUI() {
  try {
    mintPriceWei = await readMintPriceWei();
    const eth = Number(ethers.formatEther(mintPriceWei));
    mintBtn.textContent = eth > 0 ? `Mint on Base Sepolia — ${eth} ETH` : `Mint on Base Sepolia`;
  } catch {
    mintBtn.textContent = `Mint on Base Sepolia`;
  }
}

/* ============== Duplicate-Check (falls vorhanden) ============== */
async function tryDuplicateCheck(){
  try{
    if(!signer || !lastLoadedKey) return;
    const parts = lastLoadedKey.split('|');
    const sourceCollection = (parts[1] || '').trim();
    const sourceTokenId = BigInt(tokenIdInput.value.trim() || '0');
    if (!ADDRESS_RE.test(sourceCollection)) return;

    // zuerst extended versuchen (mit hasBeenUsed), sonst silently skip
    try{
      const c = new ethers.Contract(CONTRACT_ADDRESS, ABI_EXTENDED, signer);
      const already = await c.hasBeenUsed(sourceCollection, sourceTokenId);
      if (already){
        statusText.textContent = '⚠️ Already minted from this source. (blocked on-chain)';
        mintBtn.disabled = true;
      }
    }catch{}
  }catch(e){ console.warn('Duplicate check failed:', e); }
}

/* ============== NFT Fetch ============== */
function ipfsToHttp(u){ return u?.startsWith('ipfs://') ? ('https://ipfs.io/ipfs/'+u.slice(7)) : u }
async function fetchNFTImage(slug, contract, tokenId){
  try{
    const r = await fetch(`https://api.reservoir.tools/tokens/v7?tokens=${contract}:${tokenId}`);
    if(r.ok){
      const j = await r.json();
      const url = j?.tokens?.[0]?.token?.image || j?.tokens?.[0]?.token?.imageLarge;
      if(url) return ipfsToHttp(url);
    }
  }catch(e){}
  try{
    const r = await fetch(`https://api.opensea.io/api/v2/collection/${slug}/nfts/${tokenId}`);
    if(r.ok){
      const j = await r.json();
      const url = j?.nft?.image_url || j?.nft?.image_original_url;
      if(url) return ipfsToHttp(url);
    }
  }catch(e){}
  return null;
}

/* ======= Color / Lab Helpers ======= */
function clamp(v,min,max){ return Math.min(max,Math.max(min,v)); }
function rgbToHsl(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2;
  if(max===min){ h=s=0; } else { const d=max-min; s=l>0.5? d/(2-max-min): d/(max+min);
    switch(max){ case r: h=(g-b)/d+(g<b?6:0); break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break; } h/=6; }
  return [h,s,l]; }
function hslToRgb(h,s,l){ let r,g,b; if(s===0){ r=g=b=l; } else {
  const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; };
  const q=l<0.5? l*(1+s): l+s-l*s, p=2*l-q; r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3); }
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)]; }
function rgbToHex(r,g,b){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }
function dominantColorFromImage(img){
  const t=document.createElement('canvas'); t.width=64; t.height=64;
  const c=t.getContext('2d',{willReadFrequently:true});
  c.drawImage(img,0,0,64,64);
  const d=c.getImageData(0,0,64,64).data;
  const map=new Map(); const step=8;
  for(let i=0;i<d.length;i+=4*step){
    const a=d[i+3]; if(a<200) continue;
    const r=(d[i]/16|0)*16, g=(d[i+1]/16|0)*16, b=(d[i+2]/16|0)*16;
    const k=`${r},${g},${b}`; map.set(k,(map.get(k)||0)+1);
  }
  let best=null, cnt=-1;
  for(const [k,v] of map.entries()){ if(v>cnt){ best=k; cnt=v; } }
  if(!best) return {r:248,g:248,b:248};
  const [r,g,b]=best.split(',').map(n=>parseInt(n));
  return {r,g,b};
}
function pastelizeFromRGB(r,g,b){
  let [h,s,l]=rgbToHsl(r,g,b);
  l = clamp(l + 0.10, 0, 1); s = clamp(s - 0.06, 0, 1);
  const [R,G,B]=hslToRgb(h,s,l);
  return rgbToHex(R,G,B);
}

/* ============== Generator (mit Brush-Overlay) ============== */
function mulberry32(seed){ return function(){ let t=seed+=0x6D2B79F5;
  t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; }; }
function getCharacterPriorityColors(imageData, count=15){
  const colors={}, step=12, d=imageData.data;
  for(let i=0;i<d.length;i+=4*step){
    const r=d[i], g=d[i+1], b=d[i+2];
    const brightness=(r+g+b)/3;
    const saturation=Math.max(r,g,b)-Math.min(r,g,b);
    const key=`${r},${g},${b}`;
    const weight=(saturation*0.6)+(Math.abs(128-brightness)*0.2)+10;
    colors[key]=(colors[key]||0)+weight;
  }
  let sorted=Object.entries(colors).sort((a,b)=>b[1]-a[1]);
  const bg=sorted[0]?.[0]; sorted=sorted.filter(c=>c[0]!==bg);
  const top=sorted.slice(0,count*3); const out=[]; let bgShare=0;
  for(const [rgb,w] of top){
    if(w<5) continue;
    if(bgShare<2 && out.length<2){ out.push(`rgb(${rgb})`); bgShare++; }
    else if(out.length<count){ out.push(`rgb(${rgb})`); }
  }
  return out.slice(0,count);
}
const brushPatterns=[];
function createBrushPatterns(context){
  brushPatterns.length=0;
  for(let i=0;i<3;i++){
    const b=document.createElement('canvas'); b.width=40; b.height=40;
    const bc=b.getContext('2d'); bc.fillStyle=`rgba(0,0,0,${0.03+Math.random()*0.05})`;
    for(let j=0;j<50;j++){ bc.fillRect(Math.random()*40,Math.random()*40,1+Math.random()*2,1+Math.random()*2); }
    brushPatterns.push(context.createPattern(b,'repeat'));
  }
}
function generateFlowPaths(count,size,rng){
  const paths=[]; for(let i=0;i<count;i++){
    paths.push([{x:rng()*size,y:rng()*size},{x:rng()*size,y:rng()*size},{x:rng()*size,y:rng()*size}]);
  } return paths;
}
function bezierPoint(p0,p1,p2,t){
  return { x:(1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x,
           y:(1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y };
}
function drawHex(ctx, r){ ctx.beginPath(); for(let i=0;i<6;i++){ const a=(Math.PI/3)*i; ctx.lineTo(r*Math.cos(a), r*Math.sin(a)); } ctx.closePath(); ctx.fill(); }
function drawShape(x,y,size,c1,c2,context,rng){
  context.save(); context.translate(x,y); context.rotate(rng()*Math.PI);
  const g=context.createLinearGradient(-size/2,-size/2,size/2,size/2);
  g.addColorStop(0,c1); g.addColorStop(1,c2); context.fillStyle=g;
  context.shadowColor='rgba(0,0,0,0.15)'; context.shadowBlur=10*(size/100);
  context.shadowOffsetX=5*(size/150); context.shadowOffsetY=5*(size/150);
  const r=rng();
  if(r<0.2){ context.beginPath(); context.arc(0,0,size/2,0,Math.PI*2); context.fill(); }
  else if(r<0.4){ context.fillRect(-size/2,-size/2,size,size); }
  else if(r<0.6){ context.beginPath(); context.moveTo(-size/2,size/2); context.lineTo(size/2,size/2); context.lineTo(0,-size/2); context.closePath(); context.fill(); }
  else if(r<0.8){ drawHex(context,size/2); }
  else{ context.fillRect(-size/2,-size/4,size,size/2); }
  context.globalAlpha=0.8; context.fillStyle=brushPatterns[(rng()*brushPatterns.length)|0];
  context.fillRect(-size/2,-size/2,size,size); context.globalAlpha=1; context.restore();
}
function drawFlowLines(paths,ctx){ ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1;
  for(const p of paths){ ctx.beginPath(); ctx.moveTo(p[0].x,p[0].y); ctx.quadraticCurveTo(p[1].x,p[1].y,p[2].x,p[2].y); ctx.stroke(); } }
function chaosFragment(colors,sequence,drift,context,size,scale,rng){
  const big=sequence*2, mid=sequence*8, small=sequence*15;
  const paths=generateFlowPaths(drift,size,rng);
  const draw=(n,a,b)=>{ for(let i=0;i<n;i++){ const path=paths[(rng()*paths.length)|0];
    const t=rng(); const p=bezierPoint(path[0],path[1],path[2],t);
    const s=(a + rng()*(b-a))*scale; const c1=colors[(rng()*colors.length)|0]; const c2=colors[(rng()*colors.length)|0];
    drawShape(p.x,p.y,s,c1,c2,context,rng); } };
  draw(big,80,140); draw(mid,40,70); draw(small,15,30); drawFlowLines(paths,context);
}
function addNoise(context,size){
  const d=context.getImageData(0,0,size,size);
  for(let i=0;i<d.data.length;i+=4){ const n=(Math.random()-0.5)*25; d.data[i]+=n; d.data[i+1]+=n; d.data[i+2]+=n; }
  context.putImageData(d,0,0);
}

/* ============== Load NFT Button ============== */
loadBtn.addEventListener('click', async ()=>{
  const [slug,sourceCollectionAddrRaw] = (collectionSelect.value || '').split('|');
  const sourceCollectionAddr = (sourceCollectionAddrRaw || '').trim();
  const tokenId = (tokenIdInput.value || '').trim();
  if(!tokenId){ statusText.textContent='Please enter a Token ID.'; return; }
  if(!ADDRESS_RE.test(sourceCollectionAddr)){ statusText.textContent='Invalid collection address.'; return; }

  statusText.textContent='Loading NFT…';
  nftBadge.textContent='Loading…'; generateBtn.disabled=true; mintBtn.disabled=true;

  const url = await fetchNFTImage(slug, sourceCollectionAddr, tokenId);
  if(!url){ statusText.textContent='NFT not found (or CORS blocked).'; nftBadge.textContent='No NFT loaded'; return; }

  const img = new Image(); img.crossOrigin='anonymous';
  img.onload = async ()=>{
    const dom = dominantColorFromImage(img);
    bgPastelHex = pastelizeFromRGB(dom.r,dom.g,dom.b);

    ctx.fillStyle = bgPastelHex; ctx.fillRect(0,0,canvas.width,canvas.height);
    const cw=canvas.width,ch=canvas.height, ir=img.width/img.height;
    let dw=cw, dh=cw/ir; if(dh>ch){ dh=ch; dw=dh*ir; }
    const dx=(cw-dw)/2, dy=(ch-dh)/2;
    ctx.drawImage(img,dx,dy,dw,dh);

    nftImageData = ctx.getImageData(0,0,canvas.width,canvas.height);
    statusText.textContent = `Loaded • ${slug} #${tokenId}`;
    nftBadge.textContent = `${slug} #${tokenId}`;
    generateBtn.disabled=false; mintBtn.disabled=true;
    lastLoadedKey = `${slug}|${sourceCollectionAddr}|${tokenId}`;

    if (signer) { tryDuplicateCheck(); }
  };
  img.onerror = ()=>{ statusText.textContent='Failed to load image.'; nftBadge.textContent='No NFT loaded'; };
  img.src = url;
});

/* ============== Generate ============== */
generateBtn.addEventListener('click', ()=>{
  if(!nftImageData){ alert('Load an NFT first.'); return; }
  ctx.fillStyle = bgPastelHex; ctx.fillRect(0,0,canvas.width,canvas.height);
  createBrushPatterns(ctx);
  const colors = getCharacterPriorityColors(nftImageData, 15);
  const sequence = +sequenceRange.value; // DNA Frequency
  const drift = +driftRange.value;       // Gene Flow
  currentSeed = Math.floor(Math.random()*1e9);
  const rng = mulberry32(currentSeed);
  chaosFragment(colors,sequence,drift,ctx,600,1,rng);
  addNoise(ctx,600);
  statusText.textContent='Generated — ready to mint.';
  mintBtn.disabled=false;
});

/* ============== Upload helper (server/client) ============== */
async function uploadViaServer(files){
  const fd = new FormData();
  files.forEach(f => fd.append('file', f.blob, f.name));
  const r = await fetch('/api/upload',{ method:'POST', body:fd });

  let text = null, payload = null;
  try { text = await r.text(); } catch {}
  try { payload = text ? JSON.parse(text) : null; } catch {}

  if(!r.ok){
    const msg = (payload && (payload.error || payload.message)) || text || `Upload API failed (HTTP ${r.status})`;
    throw new Error(msg);
  }
  return payload || {};
}
async function uploadViaWeb3Storage(files){
  if(!WEB3_STORAGE_TOKEN) throw new Error('WEB3_STORAGE_TOKEN missing');
  const endpoint='https://api.web3.storage/upload';
  const imgRes = await fetch(endpoint,{ method:'POST', headers:{ Authorization:`Bearer ${WEB3_STORAGE_TOKEN}` }, body: files[0].blob });
  if(imgRes.status===413) throw new Error('413: image too large');
  if(!imgRes.ok) throw new Error('image upload failed');
  const imageCid = (await imgRes.json()).cid;
  const imageUrl = `ipfs://${imageCid}`;
  const meta = new Blob([files[1].text],{type:'application/json'});
  const metaRes = await fetch(endpoint,{ method:'POST', headers:{ Authorization:`Bearer ${WEB3_STORAGE_TOKEN}` }, body: meta });
  if(!metaRes.ok) throw new Error('metadata upload failed');
  const metadataCid = (await metaRes.json()).cid;
  const metadataUrl = `ipfs://${metadataCid}`;
  return { imageCid, imageUrl, metadataCid, metadataUrl };
}

/* ============== Mint Button & Share ============== */
mintBtn.addEventListener('click', async ()=>{
  try{
    if(!nftImageData){ alert('Generate first.'); return; }
    await ensureWallet(); await ensureBaseSepolia();
    await refreshMintPriceUI(); // falls sich der Preis geändert hat

    // High-res Render (JPEG 1600x1600)
    const SIZE=1600, scale=SIZE/600;
    const t=document.createElement('canvas'); t.width=SIZE; t.height=SIZE;
    const tc=t.getContext('2d');
    tc.fillStyle=bgPastelHex; tc.fillRect(0,0,SIZE,SIZE);
    createBrushPatterns(tc);
    const colors = getCharacterPriorityColors(nftImageData, 15);
    const rng = mulberry32(currentSeed);
    chaosFragment(colors, +sequenceRange.value, +driftRange.value, tc, SIZE, scale, rng);
    addNoise(tc, SIZE);

    const imgBlob = await new Promise((resolve, reject) => {
      t.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
    });
    const imageFile = { name:'visual-art.jpg', blob:imgBlob };

    const [slug, sourceCollectionRaw, sourceTokenIdStr] = (lastLoadedKey || '').split('|');
    const sourceCollection = (sourceCollectionRaw || '').trim();
    if (!ADDRESS_RE.test(sourceCollection)) throw new Error('Invalid collection address');
    const sourceTokenId = BigInt(sourceTokenIdStr || '0');

    const metadata = {
      name: `N-LABS95 — ${slug} #${sourceTokenId}`,
      description: "Experimental visual minted on Base.",
      image: "ipfs://TBD",
      attributes:[
        { trait_type:"Collection", value: slug },
        { trait_type:"DNA Frequency", value:+sequenceRange.value },
        { trait_type:"Gene Flow", value:+driftRange.value },
        { trait_type:"Source Token", value: String(sourceTokenId) }
      ]
    };

    statusText.textContent='Uploading to IPFS…';
    let result;
    if(UPLOAD_MODE==="server"){
      const metaText = JSON.stringify(metadata, null, 2);
      result = await uploadViaServer([
        imageFile,
        { name:'metadata.json', text:metaText, blob:new Blob([metaText],{type:'application/json'}) }
      ]);
    }else{
      const imgOnly = await uploadViaWeb3Storage([imageFile, {name:'meta-dummy.json', text:'{}', blob:new Blob()}]);
      metadata.image = imgOnly.imageUrl;
      const metaText = JSON.stringify(metadata, null, 2);
      result = await uploadViaWeb3Storage([
        imageFile,
        { name:'metadata.json', text:metaText, blob:new Blob([metaText],{type:'application/json'}) }
      ]);
    }
    const tokenURI = result.metadataUrl || result.metadataUrl_patched || "ipfs://dummy";
    if(!tokenURI) throw new Error('No metadata URL');

    const imageIpfs = result.imageUrl || null;
    lastImageGateway = imageIpfs ? ipfsToHttp(imageIpfs) : null;

    // Duplicate-Check nur wenn Funktion existiert
    try{
      const cExt = new ethers.Contract(CONTRACT_ADDRESS, ABI_EXTENDED, signer);
      const already = await cExt.hasBeenUsed(sourceCollection, sourceTokenId);
      if (already) { statusText.textContent = '⚠️ Already minted.'; mintBtn.disabled = true; return; }
    }catch{}

    // jetzt exakt den on-chain Preis verwenden
    const value = mintPriceWei; // <- das ist der Contract-Preis (wei)
    // mint: extended/simple ABI ist gleich signiert
    const c = new ethers.Contract(CONTRACT_ADDRESS, ABI_EXTENDED, signer);
    const tx = await c.mint(tokenURI, sourceCollection, sourceTokenId, { value });
    statusText.textContent = `Minting… Tx: ${tx.hash}`;
    const receipt = await tx.wait();

    lastTxHash = tx.hash;
    lastExplorerTx = `${EXPLORER.replace(/\/$/,'')}/tx/${tx.hash}`;
    statusText.textContent = `✅ Minted in block ${receipt.blockNumber}. View: ${lastExplorerTx}`;
    mintBtn.disabled=true;

    shareBar.style.display = 'flex';

  }catch(err){
    console.error(err);
    statusText.textContent = `❌ Mint failed: ${err?.info?.error?.message || err?.shortMessage || err?.message || String(err)}`;
  }
});

/* ============== Sharing ============== */
function buildShareText(){
  const parts = (lastLoadedKey || '').split('|');
  const slug = parts[0] || 'NFT';
  const tok = parts[2] || '';
  return `Just minted via N-LABS95 from ${slug} #${tok} on Base. ⚗️ #Base #Art`;
}
btnWarpcast.addEventListener('click', ()=>{
  const text = buildShareText();
  const embeds = [];
  if (lastImageGateway) embeds.push(lastImageGateway);
  if (lastExplorerTx) embeds.push(lastExplorerTx);
  const url = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}${
    embeds.map(e => `&embeds[]=${encodeURIComponent(e)}`).join('')
  }`;
  window.open(url, '_blank');
});
btnBaseShare.addEventListener('click', async ()=>{
  const text = buildShareText() + (lastExplorerTx ? `\n${lastExplorerTx}` : '');
  try{
    if (navigator.share) {
      await navigator.share({ title: 'My Mint', text, url: lastExplorerTx || undefined });
    } else {
      alert('System share not available — use “Copy link” or Farcaster.');
    }
  }catch(e){}
});
btnCopy.addEventListener('click', async ()=>{
  try{
    const text = lastExplorerTx || (lastImageGateway || window.location.href);
    await navigator.clipboard.writeText(text);
    statusText.textContent = '🔗 Link copied!';
  }catch(e){
    statusText.textContent = 'Could not copy link.';
  }
});

/* ============== ABOUT — Retro animation ============== */
const aboutCanvas = document.getElementById('aboutCanvas');
const actx = aboutCanvas.getContext('2d');

/* Tunables */
let ABOUT_RUNNING = true;
let COLOR_BOOST = 1.0;
const STRAND_COUNT = 2;
const POINTS_PER_STRAND = 140;
const BASE_AMPLITUDE = 110;
const SPEED = 0.012;
const HUE_BASE = 180;
const HUE_SPREAD = 140;
const GLOW = true;

let t0 = 0;
function drawAbout(ts){
  if(!ABOUT_RUNNING){ requestAnimationFrame(drawAbout); return; }
  if(!t0) t0 = ts;
  const t = (ts - t0) * SPEED;

  actx.clearRect(0,0,aboutCanvas.width,aboutCanvas.height);

  // Grid/scope
  actx.save();
  actx.globalAlpha = 0.08;
  actx.strokeStyle = '#1bff6a';
  actx.lineWidth = 1;
  for(let x=0; x<aboutCanvas.width; x+=16){
    actx.beginPath(); actx.moveTo(x,0); actx.lineTo(x,aboutCanvas.height); actx.stroke();
  }
  for(let y=0; y<aboutCanvas.height; y+=16){
    actx.beginPath(); actx.moveTo(0,y); actx.lineTo(aboutCanvas.width,y); actx.stroke();
  }
  actx.restore();

  // strands + rungs
  for(let s=0; s<STRAND_COUNT; s++){
    const phase = s===0 ? 0 : Math.PI;
    for(let i=0;i<POINTS_PER_STRAND;i++){
      const v = i/(POINTS_PER_STRAND-1);
      const y = 20 + v*(aboutCanvas.height-40);
      const wobble = Math.sin(t*1.2 + v*8.0 + s*0.6) * 8;
      const amp = BASE_AMPLITUDE + Math.sin(t*0.8 + v*4.0)*24 + wobble;
      const xCenter = aboutCanvas.width/2;
      const x = xCenter + Math.sin(v*Math.PI*2 + t*2 + phase) * amp;

      const hue = (HUE_BASE + HUE_SPREAD*Math.sin(v*6 + t*2 + s)) % 360;
      const sat = 70 + 25*Math.sin(v*5 + t*1.7 + s);
      const light = 55 + 15*Math.sin(v*7 + t*2.3 + s);
      const color = `hsl(${hue}, ${Math.max(0,Math.min(100,sat*COLOR_BOOST))}%, ${Math.max(0,Math.min(100,light))}%)`;

      if(GLOW){
        actx.shadowColor = `hsla(${hue}, 90%, 60%, 0.45)`;
        actx.shadowBlur = 8;
      } else {
        actx.shadowBlur = 0;
      }

      actx.beginPath();
      actx.fillStyle = color;
      actx.arc(x, y, 2.2 + Math.sin(v*10 + t*3 + s)*1.0, 0, Math.PI*2);
      actx.fill();

      if(i % 7 === 0){
        const otherX = xCenter + Math.sin(v*Math.PI*2 + t*2 + (s===0?Math.PI:0)) * amp;
        actx.beginPath();
        actx.strokeStyle = `hsla(${hue}, 90%, 70%, 0.55)`;
        actx.lineWidth = 1.2;
        actx.moveTo(x, y);
        actx.lineTo(otherX, y);
        actx.stroke();
      }
    }
  }

  // scanlines
  actx.save();
  actx.globalAlpha = 0.08;
  actx.fillStyle = '#00ff66';
  for(let y=0;y<aboutCanvas.height;y+=3){
    actx.fillRect(0,y,aboutCanvas.width,1);
  }
  actx.restore();

  requestAnimationFrame(drawAbout);
}
requestAnimationFrame(drawAbout);

document.getElementById('aboutPauseBtn').addEventListener('click', ()=>{
  ABOUT_RUNNING = !ABOUT_RUNNING;
  if(ABOUT_RUNNING) requestAnimationFrame(drawAbout);
});
document.getElementById('aboutBoostBtn').addEventListener('click', ()=>{
  COLOR_BOOST = COLOR_BOOST >= 1.6 ? 1.0 : (COLOR_BOOST + 0.2);
});
document.getElementById('aboutResetBtn').addEventListener('click', ()=>{
  COLOR_BOOST = 1.0; t0 = 0;
  if(!ABOUT_RUNNING){ ABOUT_RUNNING = true; requestAnimationFrame(drawAbout); }
});

/* Boot text auf dem Mint-Canvas */
(function boot(){
  ctx.fillStyle='#f8f8f8'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#000'; ctx.font='14px MS Sans Serif';
  ctx.fillText('Load NFT → Generate → Mint → Share.', 18, 28);
})();
</script>
</body>
</html>
