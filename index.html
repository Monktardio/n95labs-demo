<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>NLABS ‚Äî DNA Generator (Mini App)</title>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" />
<style>
  /* ===== Win95 Retro Shell ===== */
  :root{
    --teal:#008080; --win-blue:#000080; --chrome:#c0c0c0;
  }
  html,body{height:100%;}
  body{
    background:var(--teal);
    font-family:'MS Sans Serif', Tahoma, Arial, sans-serif;
    margin:0; display:flex; align-items:center; justify-content:center;
    padding:10px;
  }
  .desktop{max-width:980px; width:100%;}
  .window{
    background:var(--chrome);
    border:2px solid #fff; box-shadow:2px 2px 0 #000;
    padding:8px; margin:0 auto;
  }
  .title-bar{
    background:var(--win-blue); color:#fff; font-weight:bold;
    padding:4px 8px; display:flex; align-items:center; justify-content:space-between;
  }
  .title-right{display:flex; gap:6px}
  .title-btn{width:16px;height:16px;background:#c0c0c0;color:#000;border:1px solid #fff;text-align:center;line-height:14px;font-size:12px}
  .content{background:#fff;border:2px inset #c0c0c0;padding:10px}

  /* Tabs */
  .tabs{display:flex; gap:6px; margin-bottom:8px; flex-wrap:wrap}
  .tab{
    padding:4px 10px; background:#e0e0e0; border:2px outset #fff; cursor:pointer; font-size:14px;
  }
  .tab.active{background:#fff; border:2px inset #fff}
  .panel{display:none;}
  .panel.active{display:block;}

  /* Controls */
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px}
  select,input[type=text]{background:#fff;border:2px inset #fff;padding:4px;font-size:14px}
  select{min-width:260px}
  input[type=text]{width:120px}
  button{
    padding:4px 10px;background:#c0c0c0;border:2px outset #fff;cursor:pointer;font-size:14px
  }
  button:active{border:2px inset #fff}
  button:disabled{color:#777;cursor:not-allowed;border:2px inset #fff}
  label{font-size:13px}
  input[type=range]{vertical-align:middle}

  .hint{font-size:12px;color:#000080;margin:6px 0}
  .status{font-size:13px;margin-top:6px}
  .pill{padding:2px 6px;background:#ececec;border:1px solid #999;display:inline-block;font-size:12px}

  canvas{display:block;border:2px solid #000;background:#eee;margin-top:10px; width:100%; height:auto; max-width:600px}

  /* Panels content sizing */
  .two-col{display:grid; grid-template-columns:1fr; gap:10px}
  @media(min-width:960px){ .two-col{grid-template-columns:1fr 1fr;} }

  .card{
    background:#fff;border:2px inset #c0c0c0;padding:10px;
  }
  .coming{
    background:#f8f8f8;border:2px dashed #999; padding:16px; text-align:center; font-size:14px;
  }
</style>
</head>
<body>
<div class="desktop">
  <div class="window">
    <div class="title-bar">
      <div>NLABS ‚Äî Mini App</div>
      <div class="title-right">
        <div class="title-btn">_</div><div class="title-btn">‚ñ°</div><div class="title-btn">X</div>
      </div>
    </div>

    <div class="content">
      <!-- Tabs -->
      <div class="tabs" id="tabs">
        <div class="tab active" data-tab="about">About</div>
        <div class="tab" data-tab="artists">Artists</div>
        <div class="tab" data-tab="gallery">Gallery</div>
        <div class="tab" data-tab="mint">Mint</div>
      </div>

      <!-- About Panel -->
      <div class="panel active" id="panel-about">
        <div class="two-col">
          <div class="card">
            <h3>What is NLABS?</h3>
            <p>
              NLABS is a retro-styled creative lab where NFTs become ‚ÄúDNA seeds‚Äù.  
              Our algorithm extracts a genetic palette from any NFT and grows layered, geometric fragments
              along organic flow paths ‚Äî producing a unique on-chain artwork.
            </p>
            <p>
              This Mini App runs on <b>Base Sepolia</b> for testing; production will target Base mainnet.
            </p>
          </div>
          <div class="card">
            <h3>How it works</h3>
            <ol>
              <li>Pick a collection + Token ID ‚Üí load NFT.</li>
              <li>Adjust <b>Mutation</b> (shape count/size) & <b>Gene Flow</b> (path curvature).</li>
              <li>Generate your DNA artwork ‚Üí Upload to IPFS ‚Üí Mint on Base.</li>
            </ol>
          </div>
        </div>
      </div>

      <!-- Artists Panel -->
      <div class="panel" id="panel-artists">
        <div class="coming">üé® Artists ‚Äî COMING SOON (Win95 style)</div>
      </div>

      <!-- Gallery Panel -->
      <div class="panel" id="panel-gallery">
        <div class="coming">üñºÔ∏è Gallery ‚Äî COMING SOON (Win95 style)</div>
      </div>

      <!-- Mint Panel -->
      <div class="panel" id="panel-mint">
        <!-- Row 1: Load -->
        <div class="row">
          <select id="collectionSelect" title="Choose a collection">
            <option value="boredapeyachtclub|0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d">Bored Ape Yacht Club (BAYC)</option>
            <option value="mutant-ape-yacht-club|0x60e4d786628fea6478f785a6d7e704777c86a7c6">Mutant Ape Yacht Club (MAYC)</option>
            <option value="azuki|0xed5af388653567af2f388e6224dc7c4b3241c544">Azuki</option>
            <option value="doodles-official|0x8a90cab2b38dba80c64b7734e58ee1db38b8992e">Doodles</option>
            <option value="chimpers|0x80336ad7a747236ef41f47ed2c7641828a480baa">Chimpers</option>
            <option value="proof-moonbirds|0x23581767a106ae21c074b2276d25e5c3e136a68b">Moonbirds</option>
            <option value="pudgypenguins|0xbd3531da5cf5857e7cfaa92426877b022e612cf8">Pudgy Penguins</option>
            <option value="cryptopunks|0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb">CryptoPunks</option>
            <option value="mocaverse|0x59325733eb952a92e069c87f0a6168b29e80627f">Mocaverse</option>
            <option value="mfers|0x79fcdef22feed20eddacbb2587640e45491b757f">MFers</option>
          </select>
          <input id="tokenIdInput" type="text" placeholder="Token ID" />
          <button id="loadBtn" title="Load NFT image">Load NFT</button>
          <span class="pill" id="nftBadge">No NFT loaded</span>
        </div>

        <!-- Row 2: Sliders -->
        <div class="row">
          <label>Mutation:
            <input type="range" id="mutationRange" min="1" max="10" value="5" />
          </label>
          <label>Gene Flow:
            <input type="range" id="flowRange" min="1" max="10" value="6" />
          </label>
          <span class="pill" id="pricePill">Mint Price: ‚Äî</span>
          <button id="connectBtn">Connect Wallet</button>
        </div>

        <!-- Row 3: Generate / Mint -->
        <div class="row">
          <button id="generateBtn" disabled>Generate</button>
          <button id="mintBtn" disabled>Mint on Base (demo = IPFS+mint)</button>
        </div>

        <div class="hint">
          DNA Story: We read your NFT‚Äôs ‚Äúgenetic palette‚Äù (dominant colors), set a subtle pastel background from its original hue,
          then grow layered geometric fragments along organic flow paths. Mutation controls fragment count/size; Gene Flow bends the paths.
        </div>

        <canvas id="canvas" width="600" height="600" aria-label="DNA Canvas"></canvas>
        <div class="status" id="statusText">Select a collection and enter a Token ID, then click ‚ÄúLoad NFT‚Äù.</div>
      </div>
    </div>
  </div>
</div>

<!-- Ethers v6 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js" integrity="sha512-7dYhV7eG6p/3lP8WZ1E9Qy6Z7bCwA8x3G1m2Q4p+K7QqHc4Fq2G0s1f3d0t0H5Tt8Zk1vL3fC8nWw/Gx3qAZeQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
/* =========================================================
   Config ‚Äî Base Sepolia + Contract + Web3.Storage
========================================================= */
const CHAIN_ID = 84532;                 // Base Sepolia (dec)
const CHAIN_ID_HEX = '0x14A34';         // Base Sepolia (hex)
const CONTRACT_ADDRESS = '0x21CFEFfe59d808d9a2D66f8e35bDDb125c491dd6';
const BASE_SEPOLIA_PARAMS = {
  chainId: CHAIN_ID_HEX,
  chainName: 'Base Sepolia',
  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
  rpcUrls: ['https://sepolia.base.org'],
  blockExplorerUrls: ['https://sepolia.basescan.org']
};

// <-- Ersetze das hier durch deinen Token (oder injiziere via Vercel-Env) -->
const WEB3STORAGE_TOKEN = 'YOUR_WEB3STORAGE_TOKEN_HERE';

// Minimal ABI (mint + price)
const DNA_ABI = [
  "function mint(string tokenURI_) payable returns (uint256)",
  "function mintPrice() view returns (uint256)"
];

/* =========================================================
   Tabs
========================================================= */
const tabs = document.getElementById('tabs').querySelectorAll('.tab');
tabs.forEach(t => t.addEventListener('click', () => {
  tabs.forEach(x => x.classList.remove('active'));
  t.classList.add('active');
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  document.getElementById('panel-' + t.dataset.tab).classList.add('active');
}));

/* =========================================================
   UI Refs
========================================================= */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const collectionSelect = document.getElementById('collectionSelect');
const tokenIdInput = document.getElementById('tokenIdInput');
const loadBtn = document.getElementById('loadBtn');
const generateBtn = document.getElementById('generateBtn');
const mintBtn = document.getElementById('mintBtn');
const mutationRange = document.getElementById('mutationRange');
const flowRange = document.getElementById('flowRange');
const statusText = document.getElementById('statusText');
const nftBadge = document.getElementById('nftBadge');
const connectBtn = document.getElementById('connectBtn');
const pricePill = document.getElementById('pricePill');

/* =========================================================
   Wallet / Network helpers
========================================================= */
let provider = null;
let signer = null;
let userAddress = null;

async function ensureBaseSepolia() {
  if (!window.ethereum) throw new Error('No wallet found');
  const temp = new ethers.BrowserProvider(window.ethereum);
  const net = await temp.getNetwork();
  if (Number(net.chainId) === CHAIN_ID) return temp;

  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: CHAIN_ID_HEX }]
    });
  } catch (err) {
    if (err.code === 4902) {
      await window.ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [BASE_SEPOLIA_PARAMS]
      });
    } else {
      throw err;
    }
  }
  return new ethers.BrowserProvider(window.ethereum);
}

async function connectWallet() {
  try {
    provider = await ensureBaseSepolia();
    await provider.send('eth_requestAccounts', []);
    signer = await provider.getSigner();
    userAddress = await signer.getAddress();
    connectBtn.textContent = 'Connected: ' + userAddress.slice(0,6) + '‚Ä¶' + userAddress.slice(-4);
    // Mintpreis anzeigen
    const c = new ethers.Contract(CONTRACT_ADDRESS, DNA_ABI, provider);
    const p = await c.mintPrice();
    pricePill.textContent = 'Mint Price: ' + ethers.formatEther(p) + ' ETH';
  } catch (e) {
    alert('Connect failed: ' + (e?.message || e));
  }
}
connectBtn.addEventListener('click', connectWallet);

/* =========================================================
   NFT Loading (Reservoir ‚Üí OpenSea Fallback)
========================================================= */
function ipfsToHttp(url){
  if(!url) return null;
  if(url.startsWith('ipfs://')){
    return 'https://ipfs.io/ipfs/' + url.replace('ipfs://','');
  }
  return url;
}
async function fetchNFTImage(slug, contract, tokenId){
  // Reservoir
  try{
    const r = await fetch(`https://api.reservoir.tools/tokens/v7?tokens=${contract}:${tokenId}`);
    if(r.ok){
      const j=await r.json();
      const url = j?.tokens?.[0]?.token?.image || j?.tokens?.[0]?.token?.imageLarge || null;
      if(url) return ipfsToHttp(url);
    }
  }catch(e){}

  // OpenSea fallback (public; rate-limits m√∂glich)
  try{
    const r = await fetch(`https://api.opensea.io/api/v2/collection/${slug}/nfts/${tokenId}`);
    if(r.ok){
      const j=await r.json();
      const url = j?.nft?.image_url || j?.nft?.image_original_url || null;
      if(url) return ipfsToHttp(url);
    }
  }catch(e){}

  return null;
}

/* =========================================================
   Color & Background helpers (dominant pastel)
========================================================= */
function clamp(v,min,max){ return Math.min(max, Math.max(min, v)); }
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h,s,l=(max+min)/2;
  if(max===min){ h=s=0; }
  else{
    const d=max-min;
    s=l>0.5? d/(2-max-min): d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h/=6;
  }
  return [h,s,l];
}
function hslToRgb(h,s,l){
  let r,g,b;
  if(s===0){ r=g=b=l; }
  else{
    const hue2rgb=(p,q,t)=>{
      if(t<0) t+=1; if(t>1) t-=1;
      if(t<1/6) return p+(q-p)*6*t;
      if(t<1/2) return q;
      if(t<2/3) return p+(q-p)*(2/3 - t)*6;
      return p;
    };
    const q=l<0.5? l*(1+s): l+s-l*s;
    const p=2*l-q;
    r=hue2rgb(p,q,h+1/3);
    g=hue2rgb(p,q,h);
    b=hue2rgb(p,q,h-1/3);
  }
  return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
}
function rgbToHex(r,g,b){ return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }

function dominantColorFromImage(img){
  const t=document.createElement('canvas'); const s=64;
  t.width=s; t.height=s;
  const c=t.getContext('2d', { willReadFrequently:true });
  c.drawImage(img,0,0,s,s);
  const data=c.getImageData(0,0,s,s).data;
  const map=new Map(); const step=4*2;
  for(let i=0;i<data.length;i+=step){
    const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
    if(a<200) continue;
    const qr=(r/16|0)*16, qg=(g/16|0)*16, qb=(b/16|0)*16;
    const key=`${qr},${qg},${qb}`;
    map.set(key,(map.get(key)||0)+1);
  }
  let best=null, cnt=-1;
  for(const [k,v] of map.entries()){ if(v>cnt){ best=k; cnt=v; } }
  if(!best) return {r:248,g:248,b:248};
  const [r,g,b]=best.split(',').map(n=>parseInt(n,10));
  return {r,g,b};
}
function pastelizeFromRGB(r,g,b){
  let [h,s,l]=rgbToHsl(r,g,b);
  l = clamp(l + 0.08, 0, 1);
  s = clamp(s - 0.05, 0, 1);
  const [R,G,B]=hslToRgb(h,s,l);
  return rgbToHex(R,G,B);
}

/* =========================================================
   DNA Algorithm (9.4 core)
========================================================= */
let nftImage=null, nftImageData=null, currentSeed=null, bgPastelHex='#f8f8f8', lastLoadedKey=null;

function mulberry32(seed){
  return function(){
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ t>>>15, t|1);
    t ^= t + Math.imul(t ^ t>>>7, t|61);
    return ((t ^ t>>>14)>>>0)/4294967296;
  };
}
const brushPatterns=[];
function createBrushPatterns(context){
  brushPatterns.length=0;
  for(let i=0;i<3;i++){
    const b=document.createElement('canvas'); b.width=40; b.height=40;
    const bc=b.getContext('2d');
    bc.fillStyle=`rgba(0,0,0,${0.03+Math.random()*0.05})`;
    for(let j=0;j<50;j++){
      const x=Math.random()*40, y=Math.random()*40;
      bc.fillRect(x,y,1+Math.random()*2, 1+Math.random()*2);
    }
    brushPatterns.push(context.createPattern(b,'repeat'));
  }
}
function getCharacterPriorityColors(imageData, count=15){
  const colors={}; const step=12; const d=imageData.data;
  for(let i=0;i<d.length;i+=4*step){
    const r=d[i], g=d[i+1], b=d[i+2];
    const brightness=(r+g+b)/3;
    const saturation=Math.max(r,g,b) - Math.min(r,g,b);
    const key=`${r},${g},${b}`;
    const weight=(saturation*0.6)+(Math.abs(128-brightness)*0.2)+10;
    colors[key]=(colors[key]||0)+weight;
  }
  let sorted=Object.entries(colors).sort((a,b)=>b[1]-a[1]);
  const bg=sorted[0]?.[0];
  sorted=sorted.filter(c=>c[0]!==bg);
  const top=sorted.slice(0,count*3);
  const final=[]; let bgshare=0;
  for(const [rgb,weight] of top){
    if(weight<5) continue;
    if(bgshare<2 && final.length<2){ final.push(`rgb(${rgb})`); bgshare++; }
    else if(final.length<count){ final.push(`rgb(${rgb})`); }
  }
  return final.slice(0,count);
}
function chaosFragment(colors, mutation, flowIntensity, context, size, scale, rng){
  const big=mutation*2, mid=mutation*8, small=mutation*15;
  const paths=generateFlowPaths(flowIntensity,size,rng);
  drawShapes(paths, colors, big, 80,140, context, scale, rng);
  drawShapes(paths, colors, mid, 40, 70, context, scale, rng);
  drawShapes(paths, colors, small, 15, 30, context, scale, rng);
  drawFlowLines(paths, context);
}
function generateFlowPaths(count,size,rng){
  const paths=[];
  for(let i=0;i<count;i++){
    paths.push([
      {x:rng()*size, y:rng()*size},
      {x:rng()*size, y:rng()*size},
      {x:rng()*size, y:rng()*size}
    ]);
  }
  return paths;
}
function bezierPoint(p0,p1,p2,t){
  const x=(1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
  const y=(1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
  return {x,y};
}
function drawShapes(paths, colors, count, minSize, maxSize, context, scale, rng){
  for(let i=0;i<count;i++){
    const path=paths[(rng()*paths.length)|0];
    const t=rng(); const p=bezierPoint(path[0],path[1],path[2],t);
    const size=(minSize + rng()*(maxSize-minSize))*scale;
    const c1=colors[(rng()*colors.length)|0];
    const c2=colors[(rng()*colors.length)|0];
    drawShape(p.x,p.y,size,c1,c2,context,rng);
  }
}
function drawShape(x,y,size,color1,color2,context,rng){
  context.save(); context.translate(x,y); context.rotate(rng()*Math.PI);
  const g=context.createLinearGradient(-size/2,-size/2,size/2,size/2);
  g.addColorStop(0,color1); g.addColorStop(1,color2);
  context.fillStyle=g;
  context.shadowColor='rgba(0,0,0,0.15)';
  context.shadowBlur=10*(size/100);
  context.shadowOffsetX=5*(size/150);
  context.shadowOffsetY=5*(size/150);
  const r=rng();
  if(r<0.2){ context.beginPath(); context.arc(0,0,size/2,0,Math.PI*2); context.fill(); }
  else if(r<0.4){ context.fillRect(-size/2,-size/2,size,size); }
  else if(r<0.6){
    context.beginPath(); context.moveTo(-size/2,size/2); context.lineTo(size/2,size/2); context.lineTo(0,-size/2);
    context.closePath(); context.fill();
  }else if(r<0.8){ drawHex(context, size/2); }
  else{ context.fillRect(-size/2,-size/4,size,size/2); }
  context.globalAlpha=0.8;
  context.fillStyle=brushPatterns[(rng()*brushPatterns.length)|0];
  context.fillRect(-size/2,-size/2,size,size);
  context.globalAlpha=1;
  context.restore();
}
function drawHex(context, radius){
  context.beginPath();
  for(let i=0;i<6;i++){ const a=(Math.PI/3)*i; context.lineTo(radius*Math.cos(a), radius*Math.sin(a)); }
  context.closePath(); context.fill();
}
function drawFlowLines(paths,context){
  context.strokeStyle='rgba(0,0,0,0.12)'; context.lineWidth=1;
  for(const path of paths){
    context.beginPath(); context.moveTo(path[0].x, path[0].y);
    context.quadraticCurveTo(path[1].x, path[1].y, path[2].x, path[2].y); context.stroke();
  }
}
function addNoise(context,size){
  const d=context.getImageData(0,0,size,size);
  for(let i=0;i<d.data.length;i+=4){
    const n=(Math.random()-0.5)*25;
    d.data[i]+=n; d.data[i+1]+=n; d.data[i+2]+=n;
  }
  context.putImageData(d,0,0);
}

/* =========================================================
   Local "minted" blocking (demo)
========================================================= */
function mintedKey(slug, tokenId){ return `minted:${slug}:${tokenId}`; }
function isMinted(slug, tokenId){ return localStorage.getItem(mintedKey(slug,tokenId))==='1'; }
function markMinted(slug, tokenId){ localStorage.setItem(mintedKey(slug,tokenId),'1'); }

/* =========================================================
   IPFS Upload (Web3.Storage direct)
========================================================= */
async function uploadToIPFS(dataUrlPng, attributes){
  if(!WEB3STORAGE_TOKEN || WEB3STORAGE_TOKEN==='YOUR_WEB3STORAGE_TOKEN_HERE'){
    throw new Error('Missing Web3.Storage token');
  }
  // Convert dataURL ‚Üí Blob
  const res = await fetch(dataUrlPng);
  const blob = await res.blob();

  // Upload image
  const imgName = 'nlab-dna-art.png';
  const fd1 = new FormData();
  fd1.append('file', new File([blob], imgName, { type:'image/png' }));
  const up1 = await fetch('https://api.web3.storage/upload', {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${WEB3STORAGE_TOKEN}` },
    body: fd1
  });
  if(!up1.ok) throw new Error('IPFS image upload failed: '+up1.status);
  const j1 = await up1.json();
  const imageCid = j1.cid;
  const imageIpfs = `ipfs://${imageCid}`;

  // JSON metadata
  const metadata = {
    name: 'NLABS DNA Artwork',
    description: 'Generated via NLABS DNA Generator (Base Sepolia Demo)',
    image: imageIpfs,
    attributes
  };
  const metaBlob = new Blob([JSON.stringify(metadata)], { type:'application/json' });
  const fd2 = new FormData();
  fd2.append('file', new File([metaBlob], 'metadata.json', { type:'application/json' }));
  const up2 = await fetch('https://api.web3.storage/upload', {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${WEB3STORAGE_TOKEN}` },
    body: fd2
  });
  if(!up2.ok) throw new Error('IPFS metadata upload failed: '+up2.status);
  const j2 = await up2.json();
  const metaCid = j2.cid;
  return `ipfs://${metaCid}`;
}

/* =========================================================
   Wire up: Load ‚Üí Generate ‚Üí Mint
========================================================= */
let lastSlug = null, lastContract = null, lastTokenId = null;

loadBtn.addEventListener('click', async ()=>{
  const [slug, contract] = collectionSelect.value.split('|');
  const tokenId = tokenIdInput.value.trim();
  if(!tokenId){ statusText.textContent='Please enter a Token ID.'; return; }
  if(isMinted(slug, tokenId)){
    statusText.textContent='This Token ID has already been minted in the demo. Pick another ID.';
    return;
  }
  statusText.textContent='Loading NFT‚Ä¶';
  nftBadge.textContent='Loading‚Ä¶';
  generateBtn.disabled = true; mintBtn.disabled=true;

  const url = await fetchNFTImage(slug, contract, tokenId);
  if(!url){
    statusText.textContent='NFT not found (or CORS). Try another ID.';
    nftBadge.textContent='No NFT loaded';
    return;
  }
  nftImage = new Image();
  nftImage.crossOrigin='anonymous';
  nftImage.onload = ()=>{
    // Centered preview with pastel bg from dominant NFT color
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const dom = dominantColorFromImage(nftImage);
    bgPastelHex = pastelizeFromRGB(dom.r, dom.g, dom.b);
    ctx.fillStyle = bgPastelHex; ctx.fillRect(0,0,canvas.width,canvas.height);
    const cw=canvas.width, ch=canvas.height, ir=nftImage.width/nftImage.height;
    let dw=cw, dh=cw/ir; if(dh>ch){ dh=ch; dw=dh*ir; }
    const dx=(cw-dw)/2, dy=(ch-dh)/2;
    ctx.drawImage(nftImage, dx, dy, dw, dh);
    nftImageData = ctx.getImageData(0,0,canvas.width,canvas.height);

    statusText.textContent = `Loaded ‚Ä¢ ${slug} #${tokenId}`;
    nftBadge.textContent = `${slug} #${tokenId}`;
    generateBtn.disabled = false; mintBtn.disabled=true;

    lastSlug=slug; lastContract=contract; lastTokenId=tokenId;
  };
  nftImage.onerror = ()=>{
    statusText.textContent='Failed to load image (CORS or broken URL).';
    nftBadge.textContent='No NFT loaded';
  };
  nftImage.src = url;
});

generateBtn.addEventListener('click', ()=>{
  if(!nftImageData){ alert('Load an NFT first.'); return; }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = bgPastelHex; ctx.fillRect(0,0,canvas.width,canvas.height);
  createBrushPatterns(ctx);

  const colors = getCharacterPriorityColors(nftImageData, 15);
  const mutation = parseInt(mutationRange.value);
  const flow = parseInt(flowRange.value);
  currentSeed = Math.floor(Math.random()*1e9);
  const rng = mulberry32(currentSeed);

  chaosFragment(colors, mutation, flow, ctx, 600, 1, rng);
  addNoise(ctx, 600);

  statusText.textContent='Generated from NFT DNA ‚Ä¢ ready to Mint.';
  mintBtn.disabled = false;
});

mintBtn.addEventListener('click', async ()=>{
  try{
    if(!provider || !signer){ await connectWallet(); }
    if(!nftImageData){ alert('Generate first.'); return; }
    if(!lastSlug || !lastTokenId){ alert('Load an NFT first.'); return; }

    // High-res render for IPFS (balanciert, um 413 zu vermeiden)
    const exportSize = 1800;  // 1800‚Äì2000 px ist gut f√ºr Web3.Storage Limits
    const scale = exportSize / 600;
    const t=document.createElement('canvas'); t.width=exportSize; t.height=exportSize;
    const tc=t.getContext('2d');

    tc.fillStyle = bgPastelHex; tc.fillRect(0,0,exportSize,exportSize);
    createBrushPatterns(tc);
    const colors = getCharacterPriorityColors(nftImageData, 15);
    const mutation = parseInt(mutationRange.value);
    const flow = parseInt(flowRange.value);
    const rng = mulberry32(currentSeed);
    chaosFragment(colors, mutation, flow, tc, exportSize, scale, rng);
    addNoise(tc, exportSize);

    const dataUrl = t.toDataURL('image/png');

    statusText.textContent='Uploading to IPFS‚Ä¶';
    const attributes = [
      { trait_type:'Source Collection', value:lastSlug },
      { trait_type:'Token ID', value:lastTokenId },
      { trait_type:'Mutation', value:mutation },
      { trait_type:'Gene Flow', value:flow }
    ];
    const tokenUri = await uploadToIPFS(dataUrl, attributes);

    statusText.textContent='Minting on Base‚Ä¶';
    const c = new ethers.Contract(CONTRACT_ADDRESS, DNA_ABI, signer);
    const price = await c.mintPrice();
    const tx = await c.mint(tokenUri, { value: price });
    await tx.wait();

    const txUrl = `https://sepolia.basescan.org/tx/${tx.hash}`;
    statusText.innerHTML = `Minted! <a href="${txUrl}" target="_blank" rel="noopener">View Tx</a>`;
    markMinted(lastSlug, lastTokenId);
    mintBtn.disabled = true;
  }catch(e){
    console.error(e);
    alert('Mint failed: ' + (e?.message || e));
    statusText.textContent='Mint failed.';
  }
});

/* Boot paint */
(function boot(){
  ctx.fillStyle='#f8f8f8'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#000'; ctx.font='14px MS Sans Serif';
  ctx.fillText('Load an NFT, tweak DNA, then Mint on Base.', 18, 28);
})();
</script>
</body>
</html>
